<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Zorbblez – Mobile Full v5.1</title>
  <style>
    :root {
      --bg: #0B0F1F;
      --panel: rgba(0,0,0,0.35);
      --panel2: rgba(0,0,0,0.58);
      --stroke: rgba(255,255,255,0.14);
      --text: rgba(255,255,255,0.92);
      --btn: rgba(255,255,255,0.11);
      --btnHover: rgba(255,255,255,0.18);
      --good: rgba(120,255,170,0.92);
      --warn: rgba(255,210,120,0.92);
      --bad: rgba(255,120,120,0.92);
    }
    html, body { margin:0; padding:0; background:var(--bg); overflow:hidden; height:100%; }
    canvas { display:block; margin:0 auto; touch-action:none; }

    #hud {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text); font-size: 12px; line-height: 1.25;
      background: var(--panel); border: 1px solid var(--stroke);
      padding: 10px 12px; border-radius: 12px; backdrop-filter: blur(10px);
      max-width: 390px;
    }
    #hud b { font-size: 13px; }
    #hud .tiny { opacity:0.78; font-size: 11px; margin-top: 6px; }

    #panel {
      position: fixed; left: 50%; top: 50%; transform: translate(-50%,-50%);
      z-index: 30;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--panel2); border: 1px solid rgba(255,255,255,0.18);
      padding: 18px 18px 14px; border-radius: 16px;
      color: var(--text);
      width: min(92vw, 460px);
      text-align: center;
      backdrop-filter: blur(12px);
    }
    #panel h1 { font-size: 18px; margin: 0 0 10px; }
    #panel p { margin: 8px 0; font-size: 12px; opacity: 0.92; line-height: 1.35; }
    #panel input { display:none; }
    #panel .row { display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:10px; }
    #panel .note { font-size:11px; opacity:0.75; margin-top:10px; }
    #panel .status { margin-top: 10px; font-size: 12px; opacity:0.95; }
    #panel .pill { display:inline-block; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,0.16); background: rgba(255,255,255,0.08); }
    #panel .ok { color: var(--good); }
    #panel .warn { color: var(--warn); }
    #panel .bad { color: var(--bad); }

    #controls {
      position: fixed; left: 50%; bottom: 14px; transform: translateX(-50%);
      z-index: 25;
      display: flex; gap: 10px;
      padding: 10px;
      border-radius: 18px;
      background: var(--panel2);
      border: 1px solid rgba(255,255,255,0.16);
      backdrop-filter: blur(14px);
      user-select: none; -webkit-user-select: none;
      touch-action: manipulation;
    }
    .btn {
      appearance: none; border: 1px solid rgba(255,255,255,0.18);
      background: var(--btn);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      font-size: 13px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      cursor: pointer;
      min-width: 64px;
    }
    .btn:active { transform: translateY(1px); background: var(--btnHover); }
    .btn.small { min-width: 52px; padding: 10px 10px; }
    .btn.wide { min-width: 110px; }
    .btn.primary { border-color: rgba(120,255,170,0.35); background: rgba(120,255,170,0.12); }
    .hidden { display:none !important; }

    #toast {
      position: fixed; left: 50%; top: 14px; transform: translateX(-50%);
      z-index: 40;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 12px;
      color: var(--text);
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.14);
      padding: 8px 10px;
      border-radius: 999px;
      backdrop-filter: blur(10px);
      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events: none;
    }
    #toast.show { opacity: 1; }
  </style>
</head>
<body>
  <div id="toast">UI shown • will auto-hide for recording</div>

  <div id="hud">
    <b>Zorbblez – Today’s Round</b>
    <div id="hudStatus">Loading…</div>
    <div class="tiny">Tap background: pause/resume • Tap anywhere when UI hidden: show UI</div>
  </div>

  <div id="panel">
    <h1 id="panelTitle">Load today’s roster</h1>
    <p>Select up to <b id="maxCountLabel">?</b> profile images. Then press <b>Start</b> to begin the countdown.</p>

    <div class="row">
      <label class="btn wide" style="display:inline-block;">
        Choose images
        <input id="fileInput" type="file" accept="image/*" multiple />
      </label>

      <button class="btn wide" id="startNumbers" type="button">Start with numbers</button>
    </div>

    <div class="row">
      <button class="btn wide primary" id="startBtn" type="button" disabled>Start</button>
      <button class="btn wide" id="clearBtn" type="button">Clear</button>
    </div>

    <div class="status">
      <span class="pill" id="panelRoster">Roster: numbers</span>
      <span class="pill" id="panelZorb">Zorb: …</span>
      <span class="pill" id="panelAudio">Audio: locked</span>
      <span class="pill" id="panelBackend">Backend: …</span>
    </div>

    <div class="note">Tip: after you press Start, the UI will auto-hide in ~2s for clean screen recording.</div>
  </div>

  <div id="controls">
    <button class="btn wide" id="btnShowPanel" type="button">Roster</button>
    <button class="btn" id="btnPause" type="button">Pause</button>
    <button class="btn" id="btnRestart" type="button">Restart</button>
    <button class="btn small" id="btnChaosDown" type="button">–</button>
    <button class="btn small" id="btnChaosUp" type="button">+</button>
    <button class="btn wide" id="btnHide" type="button">Hide UI</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/addons/p5.sound.min.js"></script>

  <script>
  const BACKEND_BASE = "https://zorb.onrender.com";
  const ROUND_URL    = BACKEND_BASE + "/top50.json";
  const WINNER_URL   = BACKEND_BASE + "/round/today/winner";

  let ROUND_META = { round_date: null, mode: null, claimed_total: null, finale_count: null, status: null, seed: null };
  let BACKEND_WINNER = null;
  let BACKEND_OK = false;

  const CFG = {
    aspectW: 9, aspectH: 16,
    baseHeight: 1280,
    bgColor: '#0B0F1F',
    vignette: true,

    playerCount: 50,
    bubbleMinR: 42,
    bubbleMaxR: 58,
    bubbleGlow: 18,

    wanderForce: 0.16,
    maxSpeed: 2.35,
    bounceDamping: 0.985,
    separationStrength: 0.30,

    swirlStrength: 0.16,
    swirlJukeChance: 0.010,
    swirlJukeForce: 1.55,

    robotScale: 0.15,
    robotY: 0.12,
    robotHoverAmpY: 8,
    robotHoverSpeedY: 0.028,
    robotSwayFracX: 0.08,
    robotSwaySpeedX: 0.018,

    cannonXFrac: [0.34, 0.50, 0.66],
    cannonYFrac: 0.65,

    chargeTime: 10,
    fireRate: 0.75,
    fireRateFinal: 0.34,
    fireRateFinal2: 0.20,

    aimJitter: 16,
    projectileSpeed: 16,
    projectileRadius: 10,

    chaos: 1.0,
    multiElimChance: 0.08,
    nearMissChance: 0.10,
    ricochetChance: 0.06,

    screenShake: 12,
    popParticles: 22,
    popLife: 26,
    sparkLife: 18,
    slowMoFrames: 60,

    countdownSec: 3,
  };

  let audioUnlocked = false;
  let sfxPop = [];
  let sfxWinner, sfxReload, sfxFire, sfxBass, sfxWoosh, sfxTension;
  let tensionTarget = 0;
  let tensionVol = 0;
  let winnerPlayed = false;

  const SFX = {
    master: 0.90,
    pop: 0.65,
    fire: 0.65,
    reload: 0.45,
    bass: 0.75,
    woosh: 0.55,
    tensionMax: 0.55,
    winner: 0.95
  };

  let zorbImg, zorbLoaded = false;
  let rosterImgs = [];
  let rosterHandles = [];
  let players = [], projectiles = [], particles = [], stars = [];
  let paused = false, frameShake = 0;
  let zorb = { y:0, aimX:0, aimY:0, charge:0, recoil:0, fireCooldown:0 };
  let simState = "setup";
  let countdownFrames = 0;

  let hudEl, hudStatusEl, panelEl, toastEl, controlsEl, inputEl;
  let panelRosterEl, panelZorbEl, panelAudioEl, panelBackendEl, startBtnEl;
  let uiHidden = false, hideTimer = null;

  async function loadTodayRound() {
    try {
      const res = await fetch(ROUND_URL, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const round = await res.json();

      BACKEND_OK = true;

      const fc = Number(round?.finale_count || (round?.players?.length || 0) || 0);
      const finalCount = Math.max(2, Math.min(100, fc || 50));

      CFG.playerCount = finalCount;
      rosterHandles = Array.isArray(round?.players) ? round.players.map(p => (p.handle || ("#" + p.slot))) : [];

      BACKEND_WINNER = round?.winner || null;
      ROUND_META = {
        round_date: round?.round_date || null,
        mode: round?.mode || null,
        claimed_total: round?.claimed_total ?? null,
        finale_count: round?.finale_count ?? finalCount,
        status: round?.status || null,
        seed: round?.seed ?? null,
      };

      document.getElementById("maxCountLabel").textContent = String(CFG.playerCount);
      document.getElementById("panelTitle").textContent = (ROUND_META?.mode === "live") ? "Load today’s roster (LIVE)" : "Load today’s roster";

      updateHud();
      updatePanelStatus();
      return true;
    } catch (e) {
      BACKEND_OK = false;
      document.getElementById("maxCountLabel").textContent = String(CFG.playerCount);
      document.getElementById("panelTitle").textContent = "Load today’s roster (offline mode)";
      updateHud();
      updatePanelStatus();
      console.warn("Round load failed:", e);
      return false;
    }
  }

  function preload() {
    zorbImg = loadImage('Zorb2.PNG?v=4',
      () => { zorbLoaded = true; },
      () => { zorbLoaded = false; console.warn('Zorb failed to load.'); }
    );

    sfxPop = [ loadSound('pop1.mp3'), loadSound('pop2.mp3'), loadSound('pop3.mp3'), loadSound('pop4.mp3') ];
    sfxWinner  = loadSound('winner.mp3');
    sfxReload  = loadSound('reload.mp3');
    sfxFire    = loadSound('fire.mp3');
    sfxBass    = loadSound('bass.wav');
    sfxWoosh   = loadSound('woosh.wav');
    sfxTension = loadSound('tension.wav');
  }

  async function setup() {
    createOrResizeCanvas();
    hookUI();
    await loadTodayRound();
    resetSim(true);
    updatePanelStatus();
    updateHud();
  }

  function windowResized() { createOrResizeCanvas(); }

  function createOrResizeCanvas() {
    const targetH = min(windowHeight, CFG.baseHeight);
    const targetW = targetH * (CFG.aspectW / CFG.aspectH);
    const w = min(windowWidth, targetW);
    const h = w * (CFG.aspectH / CFG.aspectW);
    createCanvas(floor(w), floor(h));
    pixelDensity(window.devicePixelRatio || 2);

    stars = [];
    for (let i = 0; i < 120; i++) {
      stars.push({ x: random(width), y: random(height), r: random(0.8,2.2), tw: random(TAU), sp: random(0.006, 0.02) });
    }
  }

  function hookUI() {
    hudEl = document.getElementById('hud');
    hudStatusEl = document.getElementById('hudStatus');
    panelEl = document.getElementById('panel');
    toastEl = document.getElementById('toast');
    controlsEl = document.getElementById('controls');
    inputEl = document.getElementById('fileInput');

    panelRosterEl = document.getElementById('panelRoster');
    panelZorbEl   = document.getElementById('panelZorb');
    panelAudioEl  = document.getElementById('panelAudio');
    panelBackendEl= document.getElementById('panelBackend');
    startBtnEl    = document.getElementById('startBtn');

    document.getElementById('btnShowPanel').addEventListener('click', () => { showPanel(true); showUI(true); });
    document.getElementById('btnPause').addEventListener('click', () => { togglePause(); bumpUI(); });
    document.getElementById('btnRestart').addEventListener('click', () => { resetSim(false); showUI(true); showPanel(true); });
    document.getElementById('btnChaosDown').addEventListener('click', () => { CFG.chaos = max(0.35, CFG.chaos - 0.15); bumpUI(); });
    document.getElementById('btnChaosUp').addEventListener('click', () => { CFG.chaos = min(3.0, CFG.chaos + 0.15); bumpUI(); });
    document.getElementById('btnHide').addEventListener('click', () => { setUIHidden(true); });

    document.getElementById('startNumbers').addEventListener('click', async () => {
      await loadTodayRound();
      rosterImgs = [];
      resetSim(false);
      enableStart(true);
      beginCountdown();
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      rosterImgs = [];
      resetSim(true);
      showPanel(true);
      showUI(true);
      updatePanelStatus();
      bumpUI();
    });

    startBtnEl.addEventListener('click', () => beginCountdown());

    inputEl.addEventListener('change', async (e) => {
      await loadTodayRound();

      const files = Array.from(e.target.files || []);
      if (!files.length) return;

      shuffleInPlace(files);
      const picked = files.slice(0, CFG.playerCount);

      rosterImgs = [];
      for (const f of picked) {
        try { rosterImgs.push(await fileToP5Image(f)); }
        catch (err) { console.warn('Failed loading', f.name, err); }
      }

      shuffleInPlace(rosterImgs);

      resetSim(true);
      enableStart(true);
      updatePanelStatus();

      showPanel(true);
      showUI(true);
      bumpUI();
    });

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') onReturnToApp();
    });
    window.addEventListener('pageshow', () => onReturnToApp());
    window.addEventListener('focus', () => onReturnToApp());

    document.body.addEventListener('click', (e) => {
      resumeAudioNow();

      if (!panelEl.classList.contains('hidden')) return;
      if (uiHidden) { showUI(true); bumpUI(); return; }
      togglePause();
      bumpUI();
    }, { passive: true });

    for (const el of document.querySelectorAll('button, label.btn')) {
      el.addEventListener('click', (ev) => ev.stopPropagation());
      el.addEventListener('touchstart', (ev) => ev.stopPropagation(), { passive: true });
    }

    showPanel(true);
    showUI(true);
  }

  function enableStart(on) { startBtnEl.disabled = !on; }
  function showPanel(show) { panelEl.classList.toggle('hidden', !show); }

  function togglePause() { if (simState !== "setup") paused = !paused; }

  function beginCountdown() {
    unlockAudioOnce();
    showPanel(false);
    paused = false;
    simState = "countdown";
    countdownFrames = max(1, floor(CFG.countdownSec * 60));
    armAutoHide();
  }

  function showUI(withToast) { setUIHidden(false); if (withToast) toastPulse(); }
  function setUIHidden(hidden) { uiHidden = hidden; hudEl.classList.toggle('hidden', hidden); controlsEl.classList.toggle('hidden', hidden); }

  function toastPulse() {
    toastEl.classList.add('show');
    setTimeout(() => toastEl.classList.remove('show'), 1100);
  }

  function armAutoHide() {
    if (hideTimer) clearTimeout(hideTimer);
    setUIHidden(false);
    hideTimer = setTimeout(() => setUIHidden(true), 2200);
  }

  function bumpUI() {
    if (hideTimer) clearTimeout(hideTimer);
    setUIHidden(false);
    hideTimer = setTimeout(() => setUIHidden(true), 1800);
  }

  function fileToP5Image(file) {
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      loadImage(url, (img) => { URL.revokeObjectURL(url); resolve(img); }, (err) => { URL.revokeObjectURL(url); reject(err); });
    });
  }

  function shuffleInPlace(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = floor(random(i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  function unlockAudioOnce() {
    if (audioUnlocked) return;
    userStartAudio();
    audioUnlocked = true;
    resumeAudioNow();
    if (sfxTension) {
      sfxTension.setLoop(true);
      sfxTension.setVolume(0);
      sfxTension.play();
    }
    updatePanelStatus();
  }

  function playOne(snd, vol) {
    if (!audioUnlocked || !snd) return;
    snd.setVolume(SFX.master * vol);
    snd.play();
  }

  function playRandPop() {
    if (!audioUnlocked || !sfxPop.length) return;
    const snd = random(sfxPop);
    if (!snd) return;
    snd.setVolume(SFX.master * SFX.pop);
    snd.play();
  }

  function resumeAudioNow() {
    if (!audioUnlocked) return;
    const ctx = getAudioContext?.();
    if (ctx && ctx.state === 'suspended') ctx.resume();
    if (sfxTension) {
      try {
        if (!sfxTension.isPlaying()) { sfxTension.setLoop(true); sfxTension.play(); }
        sfxTension.setVolume(SFX.master * SFX.tensionMax * tensionVol);
      } catch (e) {}
    }
  }

  function onReturnToApp() {
    paused = false;
    resumeAudioNow();
    const ctx = getAudioContext?.();
    if (audioUnlocked && ctx && ctx.state === 'suspended') { showUI(true); bumpUI(); }
  }

  function resetSim(keepSetupState) {
    players = []; projectiles = []; particles = []; frameShake = 0;
    paused = false; winnerPlayed = false;

    zorb.y = height * CFG.robotY;
    zorb.aimX = width * 0.5;
    zorb.aimY = height * 0.5;
    zorb.charge = 0;
    zorb.recoil = 0;
    zorb.fireCooldown = 0;

    simState = keepSetupState ? "setup" : simState;
    countdownFrames = 0;

    const count = max(2, CFG.playerCount);
    let ids = Array.from({length: count}, (_, i) => i + 1);
    shuffleInPlace(ids);

    const topBound = height * 0.30;
    const minY = height * 0.32;
    const maxY = height - 22;
    const marginX = 18;

    for (let i = 0; i < count; i++) {
      const r = random(CFG.bubbleMinR, CFG.bubbleMaxR);

      let x = width * 0.5, y = (topBound + height) * 0.5;
      let ok = false;

      for (let attempt = 0; attempt < 240; attempt++) {
        x = random(r + marginX, width - r - marginX);
        y = random(minY + r, maxY - r);
        ok = true;
        for (const other of players) {
          const d = dist(x, y, other.x, other.y);
          if (d < r + other.r + 10) { ok = false; break; }
        }
        if (ok) break;
      }

      const handle = rosterHandles[i] || ("#" + ids[i]);
      players.push(new Bubble(ids[i], handle, x, y, r, rosterImgs[i] || null));
    }

    updatePanelStatus();
    updateHud();
  }

  function getRobotX() {
    const sway = sin(frameCount * CFG.robotSwaySpeedX) * (width * CFG.robotSwayFracX);
    const x = width * 0.5 + sway;
    const estHalf = (zorbLoaded && zorbImg) ? (zorbImg.width * CFG.robotScale * 0.52) : 120;
    return constrain(x, estHalf + 8, width - estHalf - 8);
  }

  function draw() {
    if (!paused) step();
    render();
    updateHud();
  }

  function step() {
    zorb.recoil *= 0.86;
    for (const s of stars) s.tw += s.sp;

    for (const b of players) b.update();
    for (let i = 0; i < players.length; i++) {
      for (let j = i + 1; j < players.length; j++) players[i].separate(players[j]);
    }

    for (let i = projectiles.length - 1; i >= 0; i--) {
      projectiles[i].update();
      if (projectiles[i].dead) projectiles.splice(i, 1);
    }
    for (let i = particles.length - 1; i >= 0; i--) {
      particles[i].update();
      if (particles[i].dead) particles.splice(i, 1);
    }

    tensionTarget = (players.length <= 5 && simState === "running") ? 1 : 0;
    tensionVol = lerp(tensionVol, tensionTarget, 0.02);
    if (audioUnlocked && sfxTension) sfxTension.setVolume(SFX.master * SFX.tensionMax * tensionVol);

    if (simState === "countdown") {
      countdownFrames -= 1;
      if (countdownFrames <= 0) { simState = "running"; countdownFrames = 0; }
      return;
    }
    if (simState !== "running") return;

    zorb.fireCooldown -= deltaTime / 1000;
    if (zorb.fireCooldown <= 0 && players.length > 1) {
      let rate = CFG.fireRate;
      if (players.length <= 5) rate = CFG.fireRateFinal;
      if (players.length <= 2) rate = CFG.fireRateFinal2;

      if (players.length <= 5 && frameCount % CFG.slowMoFrames < 10) {
      } else {
        if (zorb.charge <= 0) {
          zorb.charge = CFG.chargeTime;
          playOne(sfxReload, SFX.reload);

          const t = pickTarget();
          zorb.aimX = t.x + random(-CFG.aimJitter, CFG.aimJitter);
          zorb.aimY = t.y + random(-CFG.aimJitter, CFG.aimJitter);

          if (random() < CFG.nearMissChance * CFG.chaos) {
            zorb.aimX += random([-1, 1]) * random(40, 80);
            zorb.aimY += random(20, 60);
            playOne(sfxWoosh, SFX.woosh);
          }
        }

        zorb.charge -= 1;
        if (zorb.charge <= 0) {
          fireShot();
          zorb.fireCooldown = 1 / (rate * CFG.chaos);
        }
      }
    }

    if (players.length === 1) {
      simState = "finished";
      if (!winnerPlayed) {
        playOne(sfxWinner, SFX.winner);
        winnerPlayed = true;
        reportWinnerToBackend(players[0]).catch(()=>{});
      }
    }
  }

  function pickTarget() {
    const avoidWinner = BACKEND_WINNER && players.length > 2;
    const pool = avoidWinner ? players.filter(b => b.handle !== BACKEND_WINNER) : players;
    if (pool.length === 0) return random(players);
    if (players.length > 12) return random(pool);

    let best = pool[0], bestScore = -1e9;
    for (const b of pool) {
      const centerBias = -dist(b.x, b.y, width*0.5, height*0.62);
      const motion = b.v.mag() * 120;
      const score = centerBias + motion + random(-80, 80);
      if (score > bestScore) { bestScore = score; best = b; }
    }
    return best;
  }

  function cannonOrigins() {
    const robotX = getRobotX();
    const hoverY = sin(frameCount * CFG.robotHoverSpeedY) * CFG.robotHoverAmpY;

    const sx = CFG.robotScale;
    const imgW = (zorbLoaded && zorbImg) ? zorbImg.width * sx : 320 * sx;
    const imgH = (zorbLoaded && zorbImg) ? zorbImg.height * sx : 320 * sx;

    const left = robotX - imgW * 0.5;
    const top  = (zorb.y + hoverY) - imgH * 0.5;

    const y = top + imgH * CFG.cannonYFrac;
    return CFG.cannonXFrac.map(fr => ({ x: left + imgW * fr, y }));
  }

  function fireShot() {
    const origin = random(cannonOrigins());
    const dir = createVector(zorb.aimX - origin.x, zorb.aimY - origin.y).normalize();
    const speed = CFG.projectileSpeed * (0.85 + 0.3 * CFG.chaos);
    const vel = dir.mult(speed);

    const piercing = random() < CFG.multiElimChance * CFG.chaos;
    const ricochet = random() < CFG.ricochetChance * CFG.chaos;

    projectiles.push(new Projectile(origin.x, origin.y, vel.x, vel.y, piercing, ricochet));

    playOne(sfxFire, SFX.fire);
    zorb.recoil = 1.0;
    frameShake = max(frameShake, CFG.screenShake * (players.length <= 5 ? 1.1 : 0.8));
  }

  function render() {
    let sx = 0, sy = 0;
    if (frameShake > 0 && !paused) {
      sx = random(-frameShake, frameShake);
      sy = random(-frameShake, frameShake);
      frameShake *= 0.86;
    }

    push();
    translate(sx, sy);

    background(CFG.bgColor);
    drawStars();
    if (CFG.vignette) drawVignette();

    for (const p of projectiles) p.draw();
    for (const b of players) b.draw();
    drawZorb();
    for (const pt of particles) pt.draw();

    if (simState === "countdown") drawCountdown();
    if (simState === "finished" && players.length === 1) drawWinner(players[0]);

    pop();
  }

  function drawStars() {
    noStroke();
    for (const s of stars) {
      const tw = (sin(s.tw) * 0.5 + 0.5);
      fill(180, 200, 255, 80 + tw * 175);
      circle(s.x, s.y, s.r);
    }
  }

  function drawVignette() {
    noFill();
    for (let i = 0; i < 14; i++) {
      stroke(0,0,0,14);
      rect(-i, -i, width + 2*i, height + 2*i, 22);
    }
  }

  function drawZorb() {
    const robotX = getRobotX();
    const hoverY = sin(frameCount * CFG.robotHoverSpeedY) * CFG.robotHoverAmpY;
    const scaleAmt = CFG.robotScale * (1 + zorb.recoil * 0.01);

    if (zorbLoaded && zorbImg) {
      push();
      imageMode(CENTER);
      drawingContext.save();
      drawingContext.filter = "blur(22px)";
      tint(255, 0, 200, zorb.charge > 0 ? 180 : 110);
      image(zorbImg, robotX, zorb.y + hoverY, zorbImg.width * scaleAmt * 1.15, zorbImg.height * scaleAmt * 1.15);
      drawingContext.restore();
      pop();
    }

    imageMode(CENTER);
    if (zorbLoaded && zorbImg && zorbImg.width) {
      if (zorb.charge > 0) {
        push(); tint(255,255,255,210);
        image(zorbImg, robotX, zorb.y + hoverY, zorbImg.width * scaleAmt * 1.01, zorbImg.height * scaleAmt * 1.01);
        pop();
      }
      image(zorbImg, robotX, zorb.y + hoverY, zorbImg.width * scaleAmt, zorbImg.height * scaleAmt);
    } else {
      push();
      translate(robotX, zorb.y + hoverY);
      noStroke();
      fill(80, 240, 220, 210);
      ellipse(0,0,210,80);
      fill(255,0,200,55);
      ellipse(0,0,260,110);
      pop();
    }

    for (const o of cannonOrigins()) {
      const glow = zorb.charge > 0 ? map(zorb.charge, CFG.chargeTime, 0, 20, 130) : 18;
      noStroke();
      fill(255, 220, 0, glow);
      circle(o.x, o.y, 14);
    }
  }

  function drawCountdown() {
    const secLeft = ceil(countdownFrames / 60);
    noStroke();
    fill(0,0,0,110);
    rect(0,0,width,height);
    fill(255,255,255,240);
    textAlign(CENTER,CENTER);
    textSize(54);
    text(secLeft, width*0.5, height*0.50);
    textSize(16);
    fill(255,255,255,220);
    text("Zorbblez begins…", width*0.5, height*0.56);
  }

  function drawWinner(b) {
    noStroke();
    fill(0,0,0,120);
    rect(0,0,width,height);

    const cx = width*0.5, cy = height*0.52;
    const R  = min(width, height) * 0.23;
    const pulse = sin(frameCount*0.06)*0.5+0.5;

    noStroke();
    fill(120,220,255,30 + pulse*40);
    circle(cx, cy, R*2.45 + pulse*24);

    stroke(190,245,255,140);
    strokeWeight(5);
    fill(255,255,255,14);
    circle(cx, cy, R*2);

    noStroke();
    fill(255,255,255,58);
    ellipse(cx - R*0.28, cy - R*0.32, R*1.05, R*0.68);

    if (b.img) drawClippedImageCircle(b.img, cx, cy, R*1.62);
    else {
      fill(255,255,255,230);
      textAlign(CENTER, CENTER);
      textSize(R*0.7);
      text(b.id, cx, cy+6);
    }

    textAlign(CENTER, CENTER);
    noStroke();
    fill(255,255,255,240);
    textSize(34);
    text("WINNER!", cx, height*0.18);

    fill(255,255,255,220);
    textSize(16);
    text(b.handle ? ("@" + b.handle) : "Winner", cx, height*0.22);
  }

  function drawClippedImageCircle(img, x, y, d) {
    const ctx = drawingContext;
    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, d/2, 0, Math.PI*2);
    ctx.clip();

    const imgAR = img.width / img.height;
    let dw, dh;
    if (imgAR > 1) { dh = d; dw = d * imgAR; }
    else { dw = d; dh = d / imgAR; }
    imageMode(CENTER);
    image(img, x, y, dw, dh);

    ctx.restore();
  }

  class Bubble {
    constructor(id, handle, x, y, r, img) {
      this.id = id;
      this.handle = handle || null;
      this.x = x; this.y = y; this.r = r;
      this.img = img;

      this.v = createVector(random(-1, 1), random(-1,1)).mult(random(0.6, 1.6));
      this.wob = random(TAU);
      this.wobSp = random(0.02, 0.05);

      this.spin = random([-1, 1]) * random(0.8, 1.35);
      this.swirl = random(0.6, 1.4);
    }

    update() {
      const f = p5.Vector.random2D().mult(CFG.wanderForce * CFG.chaos);
      this.v.add(f);

      const cx = width * 0.5;
      const cy = height * 0.60;
      const toC = createVector(cx - this.x, cy - this.y);

      const tangent = createVector(-toC.y, toC.x).normalize()
        .mult(CFG.swirlStrength * this.spin * this.swirl * CFG.chaos);
      this.v.add(tangent);

      if (random() < CFG.swirlJukeChance * CFG.chaos) {
        const j = p5.Vector.random2D().mult(CFG.swirlJukeForce * random(0.7, 1.2));
        this.v.add(j);
      }

      const maxV = CFG.maxSpeed * (0.85 + 0.35 * CFG.chaos);
      if (this.v.mag() > maxV) this.v.setMag(maxV);

      this.x += this.v.x;
      this.y += this.v.y;

      const topBound = height * 0.28;
      if (this.x < this.r) { this.x = this.r; this.v.x *= -1; }
      if (this.x > width - this.r) { this.x = width - this.r; this.v.x *= -1; }
      if (this.y < topBound + this.r) { this.y = topBound + this.r; this.v.y *= -1; }
      if (this.y > height - this.r) { this.y = height - this.r; this.v.y *= -1; }

      this.v.mult(CFG.bounceDamping);
      this.wob += this.wobSp;
    }

    separate(other) {
      const dx = other.x - this.x, dy = other.y - this.y;
      const d = Math.sqrt(dx*dx + dy*dy);
      const minD = this.r + other.r + 8;
      if (d > 0 && d < minD) {
        const overlap = (minD - d) / minD;
        const push = overlap * CFG.separationStrength * (1 + 0.35 * CFG.chaos);
        const nx = dx / d, ny = dy / d;

        this.x -= nx * push * 40; this.y -= ny * push * 40;
        other.x += nx * push * 40; other.y += ny * push * 40;

        this.v.x -= nx * push * 1.2; this.v.y -= ny * push * 1.2;
        other.v.x += nx * push * 1.2; other.v.y += ny * push * 1.2;
      }
    }

    draw() {
      push();
      translate(this.x, this.y);
      const wobble = 1 + sin(this.wob) * 0.03;

      noStroke();
      fill(120, 220, 255, 24);
      circle(0, 0, this.r*2 + CFG.bubbleGlow);

      stroke(190, 245, 255, 110);
      strokeWeight(3);
      fill(255, 255, 255, 14);
      ellipse(0, 0, this.r*2*wobble, this.r*2*(2-wobble));

      if (this.img) drawClippedImageCircle(this.img, 0, 2, this.r*1.55);
      else {
        noStroke();
        fill(255,255,255,210);
        textAlign(CENTER, CENTER);
        textSize(this.r*0.6);
        text(this.id, 0, 6);
      }

      noStroke();
      fill(255,255,255,55);
      ellipse(-this.r*0.28, -this.r*0.32, this.r*0.85, this.r*0.55);

      pop();
    }
  }

  class Projectile {
    constructor(x, y, vx, vy, piercing=false, ricochet=false) {
      this.x=x; this.y=y;
      this.v=createVector(vx, vy);
      this.r=CFG.projectileRadius;
      this.dead=false;
      this.piercing=piercing;
      this.ricochet=ricochet;
      this.hasRicocheted=false;
    }

    update() {
      this.x += this.v.x;
      this.y += this.v.y;

      if (this.y > height + 120 || this.x < -120 || this.x > width + 120) {
        this.dead = true;
        return;
      }

      for (let i = players.length - 1; i >= 0; i--) {
        const b = players[i];
        if (dist(this.x, this.y, b.x, b.y) < b.r + this.r) {
          if (BACKEND_WINNER && b.handle === BACKEND_WINNER && players.length > 1) {
            this.dead = true;
            break;
          }

          popBubble(b);
          players.splice(i, 1);

          if (!this.piercing) {
            this.dead = true;
          } else {
            this.r *= 0.92;
            this.v.mult(0.92);
            if (this.r < 6) this.dead = true;
          }

          if (this.ricochet && !this.hasRicocheted && !this.dead) {
            this.hasRicocheted = true;
            const nv = p5.Vector.random2D().mult(CFG.projectileSpeed*0.85);
            nv.y = abs(nv.y) + 6;
            this.v = nv;
          }
          break;
        }
      }
    }

    draw() {
      noStroke();
      fill(255, 120, 0, 55);
      circle(this.x, this.y, this.r*4.4);
      fill(255, 240, 120, 220);
      circle(this.x, this.y, this.r*1.8);

      stroke(255, 255, 255, 70);
      strokeWeight(3);
      line(this.x, this.y, this.x - this.v.x*2.0, this.y - this.v.y*2.0);
    }
  }

  class Particle {
    constructor(x, y, vx, vy, life, kind='spark') {
      this.x=x; this.y=y;
      this.v=createVector(vx, vy);
      this.life=life;
      this.maxLife=life;
      this.kind=kind;
      this.dead=false;
      this.r=(kind === 'pop') ? random(3,7) : random(2,4);
    }
    update() {
      this.x += this.v.x;
      this.y += this.v.y;
      this.v.mult(0.93);
      this.life -= 1;
      if (this.life <= 0) this.dead = true;
    }
    draw() {
      const a = map(this.life, 0, this.maxLife, 0, 255);
      noStroke();
      if (this.kind === 'pop') fill(255,255,255,a);
      else fill(255,80,240,a);
      circle(this.x, this.y, this.r);
    }
  }

  function popBubble(b) {
    playRandPop();
    playOne(sfxBass, SFX.bass);
    frameShake = max(frameShake, CFG.screenShake*(players.length<=5?1.2:1.0));

    for (let i = 0; i < CFG.popParticles; i++) {
      const v = p5.Vector.random2D().mult(random(2.5, 8.5));
      v.y += 1.2;
      particles.push(new Particle(b.x, b.y, v.x, v.y, CFG.sparkLife, 'spark'));
    }
    for (let i = 0; i < 10; i++) {
      const v = p5.Vector.random2D().mult(random(1.2, 6.2));
      particles.push(new Particle(b.x, b.y, v.x, v.y, CFG.popLife, 'pop'));
    }
  }

  async function reportWinnerToBackend(b) {
    try {
      await fetch(WINNER_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ winner: b.handle || ("#" + b.id), winnerSlot: b.id })
      });
    } catch (e) {}
  }

  function updatePanelStatus() {
    panelRosterEl.textContent = rosterImgs.length ? `Roster: ${rosterImgs.length} images` : 'Roster: numbers';

    panelZorbEl.textContent = zorbLoaded ? 'Zorb: OK' : 'Zorb: missing';
    panelZorbEl.classList.toggle('ok', zorbLoaded);
    panelZorbEl.classList.toggle('warn', !zorbLoaded);

    panelAudioEl.textContent = audioUnlocked ? 'Audio: unlocked' : 'Audio: locked';
    panelAudioEl.classList.toggle('ok', audioUnlocked);
    panelAudioEl.classList.toggle('warn', !audioUnlocked);

    panelBackendEl.textContent = BACKEND_OK ? `Backend: OK (${CFG.playerCount})` : `Backend: offline`;
    panelBackendEl.classList.toggle('ok', BACKEND_OK);
    panelBackendEl.classList.toggle('bad', !BACKEND_OK);

    enableStart(true);
  }

  function updateHud() {
    const z = zorbLoaded ? `ok` : `MISSING Zorb2.PNG`;
    const a = audioUnlocked ? `unlocked` : `locked`;
    const state = (simState === "setup") ? "SETUP" : (simState === "countdown") ? "COUNTDOWN" : (simState === "running") ? "RUNNING" : "FINISH";
    const cd = (simState === "countdown") ? ` • starts in ${ceil(countdownFrames/60)}s` : '';
    const rd = ROUND_META?.round_date ? ` • ${ROUND_META.round_date}` : '';
    const mode = ROUND_META?.mode ? ` • ${ROUND_META.mode}` : '';
    const backend = BACKEND_OK ? ` • backend OK` : ` • backend offline`;
    const roster = rosterImgs.length ? `${rosterImgs.length} img` : `numbers`;

    hudStatusEl.innerHTML =
      `State: <b>${state}</b>${rd}${mode}${backend} • Zorb: <b>${z}</b> • Audio: <b>${a}</b>` +
      ` • Roster: <b>${roster}</b> • Players: <b>${CFG.playerCount}</b> • Remaining: <b>${players.length}</b> • Chaos: <b>${CFG.chaos.toFixed(2)}</b>${cd}` +
      (paused ? ` • <b>PAUSED</b>` : ``);

    updatePanelStatus();
  }
  </script>
</body>
</html>
