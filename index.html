<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Zorbi – Mobile Full v5.1</title>
  <style>
    :root {
      --bg: #0B0F1F;
      --panel: rgba(0,0,0,0.35);
      --panel2: rgba(0,0,0,0.58);
      --stroke: rgba(255,255,255,0.14);
      --text: rgba(255,255,255,0.92);
      --btn: rgba(255,255,255,0.11);
      --btnHover: rgba(255,255,255,0.18);
      --good: rgba(120,255,170,0.92);
      --warn: rgba(255,210,120,0.92);
      --bad: rgba(255,120,120,0.92);
    }
    html, body { margin:0; padding:0; background:var(--bg); overflow:hidden; height:100%; }
    canvas { display:block; margin:0 auto; touch-action:none; }

    /* Finale border glow overlay (full screen frame) */
    #finalGlow {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 6; /* above canvas, below hud/panel/controls */
      opacity: 0;
      transition: opacity 240ms ease;
      box-shadow:
        0 0 0 3px rgba(180, 70, 255, 0.0) inset,
        0 0 32px rgba(180, 70, 255, 0.0),
        0 0 90px rgba(255, 0, 200, 0.0);
    }
    #finalGlow.on { opacity: 1; }

    #hud {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text); font-size: 12px; line-height: 1.25;
      background: var(--panel); border: 1px solid var(--stroke);
      padding: 10px 12px; border-radius: 12px; backdrop-filter: blur(10px);
      max-width: 390px;
    }
    #hud b { font-size: 13px; }
    #hud .tiny { opacity:0.78; font-size: 11px; margin-top: 6px; }

    #panel {
      position: fixed; left: 50%; top: 50%; transform: translate(-50%,-50%);
      z-index: 30;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--panel2); border: 1px solid rgba(255,255,255,0.18);
      padding: 18px 18px 14px; border-radius: 16px;
      color: var(--text);
      width: min(92vw, 460px);
      text-align: center;
      backdrop-filter: blur(12px);
    }
    #panel h1 { font-size: 18px; margin: 0 0 10px; }
    #panel p { margin: 8px 0; font-size: 12px; opacity: 0.92; line-height: 1.35; }
    #panel input { display:none; }
    #panel .row { display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:10px; }
    #panel .note { font-size:11px; opacity:0.75; margin-top:10px; }
    #panel .status { margin-top: 10px; font-size: 12px; opacity:0.95; }
    #panel .pill { display:inline-block; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,0.16); background: rgba(255,255,255,0.08); }
    #panel .ok { color: var(--good); }
    #panel .warn { color: var(--warn); }
    #panel .bad { color: var(--bad); }

    #controls {
      position: fixed; left: 50%; bottom: 14px; transform: translateX(-50%);
      z-index: 25;
      display: flex; gap: 10px;
      padding: 10px;
      border-radius: 18px;
      background: var(--panel2);
      border: 1px solid rgba(255,255,255,0.16);
      backdrop-filter: blur(14px);
      user-select: none; -webkit-user-select: none;
      touch-action: manipulation;
    }
    .btn {
      appearance: none; border: 1px solid rgba(255,255,255,0.18);
      background: var(--btn);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      font-size: 13px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      cursor: pointer;
      min-width: 64px;
    }
    .btn:active { transform: translateY(1px); background: var(--btnHover); }
    .btn.small { min-width: 52px; padding: 10px 10px; }
    .btn.wide { min-width: 110px; }
    .btn.primary { border-color: rgba(120,255,170,0.35); background: rgba(120,255,170,0.12); }
    
    .btn.recOn { border-color: rgba(180,100,255,0.75); box-shadow: 0 0 22px rgba(180,100,255,0.45); }
    .pill.purple { border-color: rgba(180,100,255,0.40); box-shadow: 0 0 18px rgba(180,100,255,0.25); }
.hidden { display:none !important; }

    #toast {
      position: fixed; left: 50%; top: 14px; transform: translateX(-50%);
      z-index: 40;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 12px;
      color: var(--text);
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.14);
      padding: 8px 10px;
      border-radius: 999px;
      backdrop-filter: blur(10px);
      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events: none;
    }
    #toast.show { opacity: 1; }
  </style>
</head>
<body>
  <div id="toast">UI shown • will auto-hide for recording</div>
  <div id="finalGlow"></div>

  <div id="hud">
    <b>Zorbi – Today’s Round</b>
    <div id="hudStatus">Loading…</div>
    <div class="tiny">Tap background: pause/resume • Tap anywhere when UI hidden: show UI</div>
  </div>

  <div id="panel">
    <h1 id="panelTitle">Load today’s roster</h1>
    <p>Today’s roster supports up to <b id="maxCountLabel">?</b> entrants. Press <b>Start</b> to begin the countdown.</p>

    <div class="row">
      <button class="btn wide" id="startNumbers" type="button">Start with numbers</button>
    </div>

    <div class="row">
      <button class="btn wide primary" id="startBtn" type="button" disabled>Start</button>
      <button class="btn wide" id="clearBtn" type="button">Clear</button>
    </div>

    <div class="status">
      <span class="pill" id="panelRoster">Roster: handles</span>
      <span class="pill" id="panelZorb">Zorb: …</span>
      <span class="pill" id="panelAudio">Audio: locked</span>
      <span class="pill" id="panelBackend">Backend: …</span>
          <span class="pill" id="panelVideo">Video: off</span>
</div>

    <div class="note">Tip: after you press Start, the UI will auto-hide in ~2s for clean screen recording.</div>
  </div>

  <div id="controls">
    <button class="btn wide" id="btnShowPanel" type="button">Roster</button>
    <button class="btn" id="btnPause" type="button">Pause</button>
    <button class="btn" id="btnRestart" type="button">Restart</button>
    
    <button class="btn" id="btnRec" type="button">Rec</button>
    <button class="btn small" id="btnAutoUp" type="button" title="Auto-upload video when finished">↑</button>
<button class="btn small" id="btnChaosDown" type="button">–</button>
    <button class="btn small" id="btnChaosUp" type="button">+</button>
    <button class="btn wide" id="btnHide" type="button">Hide UI</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/addons/p5.sound.min.js"></script>

  <script>
  const BACKEND_BASE =
    (location.hostname === "localhost" || location.hostname === "127.0.0.1")
      ? "http://localhost:10000"
      : "https://zorb.onrender.com";
  const ROUND_URL    = BACKEND_BASE + "/top50.json";
  const WINNER_URL   = BACKEND_BASE + "/round/today/winner";
  const VIDEO_UPLOAD_URL = BACKEND_BASE + "/api/round/today/video";
  let UPLOAD_TOKEN = null;

  // -------- Auto recording (canvas -> MediaRecorder) --------
  let recEnabled = true;      // turn off if you want
  let recAutoUpload = true;   // toggle with ↑ button
  let recording = false;
  let mediaRecorder = null;
  let recChunks = [];
  let lastVideoUrl = null;


  let ROUND_META = { round_date: null, mode: null, claimed_total: null, finale_count: null, status: null, seed: null };
  let BACKEND_WINNER = null;
  let BACKEND_OK = false;

  const CFG = {
    aspectW: 9, aspectH: 16,
    baseHeight: 1280,
    bgColor: '#0B0F1F',
    vignette: true,

    playerCount: 50,
    bubbleMinR: 42,
    bubbleMaxR: 58,
    bubbleGlow: 18,

    wanderForce: 0.16,
    maxSpeed: 2.35,
    bounceDamping: 0.985,
    separationStrength: 0.30,

    swirlStrength: 0.16,
    swirlJukeChance: 0.010,
    swirlJukeForce: 1.55,

    robotScale: 0.15,
    robotY: 0.12,
    robotHoverAmpY: 8,
    robotHoverSpeedY: 0.028,
    robotSwayFracX: 0.08,
    robotSwaySpeedX: 0.018,

    cannonXFrac: [0.34, 0.50, 0.66],
    cannonYFrac: 0.65,

    chargeTime: 10,
    fireRate: 0.75,
    fireRateFinal: 0.34,
    fireRateFinal2: 0.20,

    aimJitter: 16,
    projectileSpeed: 16,
    projectileRadius: 10,

    chaos: 1.0,
    multiElimChance: 0.08,
    nearMissChance: 0.10,
    ricochetChance: 0.06,

    screenShake: 12,
    popParticles: 22,
    popLife: 26,
    sparkLife: 18,
    slowMoFrames: 60,

    countdownSec: 3,
  };

  let audioUnlocked = false;
  let sfxPop = [];
  let sfxWinner, sfxReload, sfxFire, sfxBass, sfxWoosh, sfxTension;
  let tensionTarget = 0;
  let tensionVol = 0;
  let winnerPlayed = false;

  const SFX = {
    master: 0.90,
    pop: 0.65,
    fire: 0.65,
    reload: 0.45,
    bass: 0.75,
    woosh: 0.55,
    tensionMax: 0.55,
    winner: 0.95
  };

  let zorbImg, zorbLoaded = false;
  let rosterImgs = null; // images disabled
let rosterHandles = [];
  let players = [], projectiles = [], particles = [], stars = [];
  let paused = false, frameShake = 0;
  let zorb = { y:0, aimX:0, aimY:0, charge:0, recoil:0, fireCooldown:0 };
  let simState = "setup";
  let countdownFrames = 0;

  let hudEl, hudStatusEl, panelEl, toastEl, controlsEl, inputEl;
  let panelRosterEl, panelZorbEl, panelAudioEl, panelBackendEl, panelVideoEl, startBtnEl;
  let btnRecEl, btnAutoUpEl;
  let finalGlowEl;
  let uiHidden = false, hideTimer = null;

  // Performance / iOS stability
  let lastHudUpdateMs = 0;
  let lastPanelUpdateMs = 0;
  let wakeLock = null;


  async function loadTodayRound() {
    try {
      const ctrl = new AbortController();
      const to = setTimeout(() => ctrl.abort(), 6500);
      const res = await fetch(ROUND_URL, { cache: "no-store", signal: ctrl.signal });
      clearTimeout(to);
      if (!res.ok) throw new Error("HTTP " + res.status);
      const round = await res.json();

      BACKEND_OK = true;

      const fc = Number(round?.finale_count || (round?.players?.length || 0) || 0);
      const finalCount = Math.max(2, Math.min(100, fc || 50));

      CFG.playerCount = finalCount;
      rosterHandles = Array.isArray(round?.players)
        ? round.players.map(p => (p.handle || ("#" + p.slot)))
        : [];

      BACKEND_WINNER = round?.winner || null;
      ROUND_META = {
        round_date: round?.round_date || null,
        mode: round?.mode || null,
        claimed_total: round?.claimed_total ?? null,
        finale_count: round?.finale_count ?? finalCount,
        status: round?.status || null,
        seed: round?.seed ?? null,
      };

      UPLOAD_TOKEN = round?.upload_token || null;

      document.getElementById("maxCountLabel").textContent = String(CFG.playerCount);
      document.getElementById("panelTitle").textContent =
        (ROUND_META?.mode === "live") ? "Load today’s roster (LIVE)" : "Load today’s roster";

      updateHud();
      updatePanelStatus();
      return true;
    } catch (e) {
      BACKEND_OK = false;
      document.getElementById("maxCountLabel").textContent = String(CFG.playerCount);
      document.getElementById("panelTitle").textContent = "Load today’s roster (offline mode)";
      updateHud();
      updatePanelStatus();
      console.warn("Round load failed:", e);
      return false;
    }
  }

  function preload() {
    zorbImg = loadImage('Zorb2.PNG?v=4',
      () => { zorbLoaded = true; },
      () => { zorbLoaded = false; console.warn('Zorb failed to load.'); }
    );

    sfxPop = [ loadSound('pop1.mp3'), loadSound('pop2.mp3'), loadSound('pop3.mp3'), loadSound('pop4.mp3') ];
    sfxWinner  = loadSound('winner.mp3');
    sfxReload  = loadSound('reload.mp3');
    sfxFire    = loadSound('fire.mp3');
    sfxBass    = loadSound('bass.wav');
    sfxWoosh   = loadSound('woosh.wav');
    sfxTension = loadSound('tension.wav');
  }

  async function setup() {
    createOrResizeCanvas();
    hookUI();
    await loadTodayRound();
    resetSim(true);
    updatePanelStatusThrottled(true);
    updateHudThrottled();
  }

  function windowResized() { createOrResizeCanvas(); }

  function createOrResizeCanvas() {
    const targetH = min(windowHeight, CFG.baseHeight);
    const targetW = targetH * (CFG.aspectW / CFG.aspectH);
    const w = min(windowWidth, targetW);
    const h = w * (CFG.aspectH / CFG.aspectW);
    createCanvas(floor(w), floor(h));
    // iOS Safari can reload/crash under heavy GPU load; keep pixel density conservative.
    const dpr = window.devicePixelRatio || 2;
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const pd = isIOS ? Math.min(1.5, dpr) : Math.min(2, dpr);
    pixelDensity(pd);

    stars = [];
    for (let i = 0; i < 120; i++) {
      stars.push({ x: random(width), y: random(height), r: random(0.8,2.2), tw: random(TAU), sp: random(0.006, 0.02) });
    }
  }

  function hookUI() {
    hudEl = document.getElementById('hud');
    hudStatusEl = document.getElementById('hudStatus');
    panelEl = document.getElementById('panel');
    toastEl = document.getElementById('toast');
    controlsEl = document.getElementById('controls');finalGlowEl = document.getElementById('finalGlow');

    panelRosterEl = document.getElementById('panelRoster');
    panelZorbEl   = document.getElementById('panelZorb');
    panelAudioEl  = document.getElementById('panelAudio');
    panelBackendEl= document.getElementById('panelBackend');
    panelVideoEl = document.getElementById('panelVideo');
    btnRecEl = document.getElementById('btnRec');
    btnAutoUpEl = document.getElementById('btnAutoUp');
    startBtnEl    = document.getElementById('startBtn');

    document.getElementById('btnShowPanel').addEventListener('click', () => { showPanel(true); showUI(true); });
    document.getElementById('btnPause').addEventListener('click', () => { togglePause(); bumpUI(); });
    document.getElementById('btnRestart').addEventListener('click', () => { resetSim(false); showUI(true); showPanel(true); });
    document.getElementById('btnChaosDown').addEventListener('click', () => { CFG.chaos = max(0.35, CFG.chaos - 0.15); bumpUI(); });
    document.getElementById('btnChaosUp').addEventListener('click', () => { CFG.chaos = min(3.0, CFG.chaos + 0.15); bumpUI(); });
    document.getElementById('btnHide').addEventListener('click', () => { setUIHidden(true); });

    btnRecEl.addEventListener('click', async () => {
      btnRecEl.textContent = recEnabled ? 'Rec' : 'Rec';
      recEnabled = !recEnabled;
      if (!recEnabled && recording) await stopRecording(false);
      bumpUI();
      updatePanelStatus();
    });

    btnAutoUpEl.addEventListener('click', () => {
      recAutoUpload = !recAutoUpload;
      bumpUI();
      updatePanelStatus();
    });

    document.getElementById('startNumbers').addEventListener('click', async () => {
      await loadTodayRound();
      // images disabled

      resetSim(false);
      enableStart(true);
      beginCountdown();
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      // images disabled

      resetSim(true);
      showPanel(true);
      showUI(true);
      updatePanelStatus();
      bumpUI();
    });

    startBtnEl.addEventListener('click', () => beginCountdown());

    
      const files = Array.from(e.target.files || []);
      if (!files.length) return;

      shuffleInPlace(files);
      const picked = files.slice(0, CFG.playerCount);

      // images disabled

      for (const f of picked) {
        try { rosterImgs.push(await fileToP5Image(f)); }
        catch (err) { console.warn('Failed loading', f.name, err); }
      }

      shuffleInPlace(rosterImgs);

      resetSim(true);
      enableStart(true);
      updatePanelStatus();

      showPanel(true);
      showUI(true);
      bumpUI();
    });

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') onReturnToApp();
    });
    window.addEventListener('pageshow', () => onReturnToApp());
    window.addEventListener('focus', () => onReturnToApp());

    document.body.addEventListener('click', (e) => {
      resumeAudioNow();
    if (simState === 'running' || simState === 'countdown') requestWakeLock();

      if (!panelEl.classList.contains('hidden')) return;
      if (uiHidden) { showUI(true); bumpUI(); return; }
      togglePause();
      bumpUI();
    }, { passive: true });

    for (const el of document.querySelectorAll('button, label.btn')) {
      el.addEventListener('click', (ev) => ev.stopPropagation());
      el.addEventListener('touchstart', (ev) => ev.stopPropagation(), { passive: true });
    }

    showPanel(true);
    showUI(true);
  }

  function enableStart(on) { startBtnEl.disabled = !on; }
  function showPanel(show) { panelEl.classList.toggle('hidden', !show); }

  function togglePause() { if (simState !== "setup") paused = !paused; }

  function beginCountdown() {
    unlockAudioOnce();
    requestWakeLock();
    showPanel(false);
    paused = false;
    simState = "countdown";
    countdownFrames = max(1, floor(CFG.countdownSec * 60));
    armAutoHide();
    if (recEnabled) startRecording();
  }

  function showUI(withToast) { setUIHidden(false); if (withToast) toastPulse(); }
  function setUIHidden(hidden) { uiHidden = hidden; hudEl.classList.toggle('hidden', hidden); controlsEl.classList.toggle('hidden', hidden); }

  function toastPulse() {
    toastEl.classList.add('show');
    setTimeout(() => toastEl.classList.remove('show'), 1100);
  }

  function armAutoHide() {
    if (hideTimer) clearTimeout(hideTimer);
    setUIHidden(false);
    hideTimer = setTimeout(() => setUIHidden(true), 2200);
  }

  function bumpUI() {
    if (hideTimer) clearTimeout(hideTimer);
    setUIHidden(false);
    hideTimer = setTimeout(() => setUIHidden(true), 1800);
  }

  
  function unlockAudioOnce() {
    if (audioUnlocked) return;
    userStartAudio();
    audioUnlocked = true;
    resumeAudioNow();
    if (simState === 'running' || simState === 'countdown') requestWakeLock();
    if (sfxTension) {
      sfxTension.setLoop(true);
      sfxTension.setVolume(0);
      sfxTension.play();
    }
    updatePanelStatusThrottled(true);
  }

  function playOne(snd, vol) {
    if (!audioUnlocked || !snd) return;
    snd.setVolume(SFX.master * vol);
    snd.play();
  }

  function playRandPop() {
    if (!audioUnlocked || !sfxPop.length) return;
    const snd = random(sfxPop);
    if (!snd) return;
    snd.setVolume(SFX.master * SFX.pop);
    snd.play();
  }

  function resumeAudioNow() {
    if (!audioUnlocked) return;
    const ctx = getAudioContext?.();
    if (ctx && ctx.state === 'suspended') ctx.resume();
    if (sfxTension) {
      try {
        if (!sfxTension.isPlaying()) { sfxTension.setLoop(true); sfxTension.play(); }
        sfxTension.setVolume(SFX.master * SFX.tensionMax * tensionVol);
      } catch (e) {}
    }
  }

  function onReturnToApp() {
    paused = false;
    resumeAudioNow();
    if (simState === 'running' || simState === 'countdown') requestWakeLock();
    const ctx = getAudioContext?.();
    if (audioUnlocked && ctx && ctx.state === 'suspended') { showUI(true); bumpUI(); }
  }

  // Keep the screen awake during a run (best-effort; may not be supported on all browsers)
  async function requestWakeLock() {
    try {
      if (!('wakeLock' in navigator)) return;
      if (wakeLock) return;
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', () => { wakeLock = null; });
    } catch (_) {
      // ignore
    }
  }
  function releaseWakeLock() {
    try { wakeLock?.release?.(); } catch (_) {}
    wakeLock = null;
  }

  // Finale border glow (pulses when final 5)
  function updateFinaleGlow() {
    if (!finalGlowEl) return;

    const isFinale = (simState === "running" && players.length <= 5);
    finalGlowEl.classList.toggle('on', isFinale);

    if (!isFinale) return;

    const t = frameCount * 0.06;
    const pulse = (sin(t) * 0.5 + 0.5); // 0..1
    const a1 = 0.18 + pulse * 0.32;     // inner frame
    const a2 = 0.22 + pulse * 0.55;     // outer glow
    const a3 = 0.16 + pulse * 0.55;     // big magenta bloom

    finalGlowEl.style.boxShadow =
      `0 0 0 3px rgba(180, 70, 255, ${a1}) inset,
       0 0 32px rgba(180, 70, 255, ${a2}),
       0 0 90px rgba(255, 0, 200, ${a3})`;
  }

  function resetSim(keepSetupState) {
    players = []; projectiles = []; particles = []; frameShake = 0;
    paused = false; winnerPlayed = false;

    zorb.y = height * CFG.robotY;
    zorb.aimX = width * 0.5;
    zorb.aimY = height * 0.5;
    zorb.charge = 0;
    zorb.recoil = 0;
    zorb.fireCooldown = 0;

    simState = keepSetupState ? "setup" : simState;
    countdownFrames = 0;

    const count = max(2, CFG.playerCount);
    let ids = Array.from({length: count}, (_, i) => i + 1);
    shuffleInPlace(ids);

    const topBound = height * 0.30;
    const minY = height * 0.32;
    const maxY = height - 22;
    const marginX = 18;

    for (let i = 0; i < count; i++) {
      const r = random(CFG.bubbleMinR, CFG.bubbleMaxR);

      let x = width * 0.5, y = (topBound + height) * 0.5;
      let ok = false;

      for (let attempt = 0; attempt < 240; attempt++) {
        x = random(r + marginX, width - r - marginX);
        y = random(minY + r, maxY - r);
        ok = true;
        for (const other of players) {
          const d = dist(x, y, other.x, other.y);
          if (d < r + other.r + 10) { ok = false; break; }
        }
        if (ok) break;
      }

      const handle = rosterHandles[i] || ("#" + ids[i]);
      players.push(new Bubble(ids[i], handle, x, y, r, null));
    }

    updatePanelStatusThrottled(true);
    updateHudThrottled();
  }

  function getRobotX() {
    const sway = sin(frameCount * CFG.robotSwaySpeedX) * (width * CFG.robotSwayFracX);
    const x = width * 0.5 + sway;
    const estHalf = (zorbLoaded && zorbImg) ? (zorbImg.width * CFG.robotScale * 0.52) : 120;
    return constrain(x, estHalf + 8, width - estHalf - 8);
  }

  function draw() {
    if (!paused) step();
    render();
    updateFinaleGlow();
    updateHudThrottled();
  }

  function step() {
    zorb.recoil *= 0.86;
    for (const s of stars) s.tw += s.sp;

    for (const b of players) b.update();
    for (let i = 0; i < players.length; i++) {
      for (let j = i + 1; j < players.length; j++) players[i].separate(players[j]);
    }

    for (let i = projectiles.length - 1; i >= 0; i--) {
      projectiles[i].update();
      if (projectiles[i].dead) projectiles.splice(i, 1);
    }
    for (let i = particles.length - 1; i >= 0; i--) {
      particles[i].update();
      if (particles[i].dead) particles.splice(i, 1);
    }

    tensionTarget = (players.length <= 5 && simState === "running") ? 1 : 0;
    tensionVol = lerp(tensionVol, tensionTarget, 0.02);
    if (audioUnlocked && sfxTension) sfxTension.setVolume(SFX.master * SFX.tensionMax * tensionVol);

    if (simState === "countdown") {
      countdownFrames -= 1;
      if (countdownFrames <= 0) { simState = "running"; countdownFrames = 0; }
      return;
    }
    if (simState !== "running") return;

    zorb.fireCooldown -= deltaTime / 1000;
    if (zorb.fireCooldown <= 0 && players.length > 1) {
      let rate = CFG.fireRate;
      if (players.length <= 5) rate = CFG.fireRateFinal;
      if (players.length <= 2) rate = CFG.fireRateFinal2;

      if (players.length <= 5 && frameCount % CFG.slowMoFrames < 10) {
      } else {
        if (zorb.charge <= 0) {
          zorb.charge = CFG.chargeTime;
          playOne(sfxReload, SFX.reload);

          const t = pickTarget();
          zorb.aimX = t.x + random(-CFG.aimJitter, CFG.aimJitter);
          zorb.aimY = t.y + random(-CFG.aimJitter, CFG.aimJitter);

          if (random() < CFG.nearMissChance * CFG.chaos) {
            zorb.aimX += random([-1, 1]) * random(40, 80);
            zorb.aimY += random(20, 60);
            playOne(sfxWoosh, SFX.woosh);
          }
        }

        zorb.charge -= 1;
        if (zorb.charge <= 0) {
          fireShot();
          zorb.fireCooldown = 1 / (rate * CFG.chaos);
        }
      }
    }

    if (players.length === 1) {
      simState = "finished";
      if (!winnerPlayed) {
        playOne(sfxWinner, SFX.winner);
        winnerPlayed = true;
        // stop recording first so we capture the winner screen
        stopRecording(true).catch(()=>{});
        reportWinnerToBackend(players[0]).catch(()=>{});
        releaseWakeLock();
      }
    }
  }

  function pickTarget() {
    const avoidWinner = BACKEND_WINNER && players.length > 2;
    const pool = avoidWinner ? players.filter(b => b.handle !== BACKEND_WINNER) : players;
    if (pool.length === 0) return random(players);
    if (players.length > 12) return random(pool);

    let best = pool[0], bestScore = -1e9;
    for (const b of pool) {
      const centerBias = -dist(b.x, b.y, width*0.5, height*0.62);
      const motion = b.v.mag() * 120;
      const score = centerBias + motion + random(-80, 80);
      if (score > bestScore) { bestScore = score; best = b; }
    }
    return best;
  }

  function cannonOrigins() {
    const robotX = getRobotX();
    const hoverY = sin(frameCount * CFG.robotHoverSpeedY) * CFG.robotHoverAmpY;

    const sx = CFG.robotScale;
    const imgW = (zorbLoaded && zorbImg) ? zorbImg.width * sx : 320 * sx;
    const imgH = (zorbLoaded && zorbImg) ? zorbImg.height * sx : 320 * sx;

    const left = robotX - imgW * 0.5;
    const top  = (zorb.y + hoverY) - imgH * 0.5;

    const y = top + imgH * CFG.cannonYFrac;
    return CFG.cannonXFrac.map(fr => ({ x: left + imgW * fr, y }));
  }

  function fireShot() {
    const origin = random(cannonOrigins());
    const dir = createVector(zorb.aimX - origin.x, zorb.aimY - origin.y).normalize();
    const speed = CFG.projectileSpeed * (0.85 + 0.3 * CFG.chaos);
    const vel = dir.mult(speed);

    const piercing = random() < CFG.multiElimChance * CFG.chaos;
    const ricochet = random() < CFG.ricochetChance * CFG.chaos;

    projectiles.push(new Projectile(origin.x, origin.y, vel.x, vel.y, piercing, ricochet));

    playOne(sfxFire, SFX.fire);
    zorb.recoil = 1.0;
    frameShake = max(frameShake, CFG.screenShake * (players.length <= 5 ? 1.1 : 0.8));
  }

  function render() {
    let sx = 0, sy = 0;
    if (frameShake > 0 && !paused) {
      sx = random(-frameShake, frameShake);
      sy = random(-frameShake, frameShake);
      frameShake *= 0.86;
    }

    push();
    translate(sx, sy);

    background(CFG.bgColor);
    drawStars();
    if (CFG.vignette) drawVignette();

    for (const p of projectiles) p.draw();
    for (const b of players) b.draw();
    drawZorb();
    for (const pt of particles) pt.draw();

    if (simState === "countdown") drawCountdown();
    if (simState === "finished" && players.length === 1) {
      drawFinaleAura();
      drawWinner(players[0]);
    }

    pop();
  }

  function drawStars() {
    noStroke();
    for (const s of stars) {
      const tw = (sin(s.tw) * 0.5 + 0.5);
      fill(180, 200, 255, 80 + tw * 175);
      circle(s.x, s.y, s.r);
    }
  }

  function drawVignette() {
    noFill();
    for (let i = 0; i < 14; i++) {
      stroke(0,0,0,14);
      rect(-i, -i, width + 2*i, height + 2*i, 22);
    }
  }

  function drawFinaleAura() {
    const ctx = drawingContext;
    ctx.save();

    const cx = width * 0.5;
    const cy = height * 0.5;
    const radius = max(width, height) * 0.85;

    const gradient = ctx.createRadialGradient(
      cx, cy, radius * 0.2,
      cx, cy, radius
    );

    gradient.addColorStop(0, "rgba(160, 80, 255, 0.25)");
    gradient.addColorStop(0.4, "rgba(130, 50, 255, 0.18)");
    gradient.addColorStop(1, "rgba(80, 0, 180, 0.45)");

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    ctx.restore();
  }

  function drawZorb() {
    const robotX = getRobotX();
    const hoverY = sin(frameCount * CFG.robotHoverSpeedY) * CFG.robotHoverAmpY;
    const scaleAmt = CFG.robotScale * (1 + zorb.recoil * 0.01);

    if (zorbLoaded && zorbImg) {
      push();
      imageMode(CENTER);
      drawingContext.save();
      drawingContext.filter = "blur(22px)";
      tint(255, 0, 200, zorb.charge > 0 ? 180 : 110);
      image(zorbImg, robotX, zorb.y + hoverY, zorbImg.width * scaleAmt * 1.15, zorbImg.height * scaleAmt * 1.15);
      drawingContext.restore();
      pop();
    }

    imageMode(CENTER);
    if (zorbLoaded && zorbImg && zorbImg.width) {
      if (zorb.charge > 0) {
        push(); tint(255,255,255,210);
        image(zorbImg, robotX, zorb.y + hoverY, zorbImg.width * scaleAmt * 1.01, zorbImg.height * scaleAmt * 1.01);
        pop();
      }
      image(zorbImg, robotX, zorb.y + hoverY, zorbImg.width * scaleAmt, zorbImg.height * scaleAmt);
    } else {
      push();
      translate(robotX, zorb.y + hoverY);
      noStroke();
      fill(80, 240, 220, 210);
      ellipse(0,0,210,80);
      fill(255,0,200,55);
      ellipse(0,0,260,110);
      pop();
    }

    for (const o of cannonOrigins()) {
      const glow = zorb.charge > 0 ? map(zorb.charge, CFG.chargeTime, 0, 20, 130) : 18;
      noStroke();
      fill(255, 220, 0, glow);
      circle(o.x, o.y, 14);
    }
  }

  function drawCountdown() {
    const secLeft = ceil(countdownFrames / 60);
    noStroke();
    fill(0,0,0,110);
    rect(0,0,width,height);
    fill(255,255,255,240);
    textAlign(CENTER,CENTER);
    textSize(54);
    text(secLeft, width*0.5, height*0.50);
    textSize(16);
    fill(255,255,255,220);
    text("Zorbi begins…", width*0.5, height*0.56);
  }

  function drawWinner(b) {
    noStroke();
    fill(0,0,0,120);
    rect(0,0,width,height);

    const cx = width*0.5, cy = height*0.52;
    const R  = min(width, height) * 0.23;
    const pulse = sin(frameCount*0.06)*0.5+0.5;

    // Purple outer glow burst
    noStroke();
    fill(160, 80, 255, 40 + pulse*50);
    circle(cx, cy, R*2.8 + pulse*30);

    // Main ring
    stroke(190,245,255,140);
    strokeWeight(5);
    fill(255,255,255,14);
    circle(cx, cy, R*2);

    // Bubble shine
    noStroke();
    fill(255,255,255,58);
    ellipse(cx - R*0.28, cy - R*0.32, R*1.05, R*0.68);

    // Bubble content
    {
      const label = (b.handle ? "@" + b.handle : String(b.id));
      let ts = R * 0.52;
      if (label.length > 8) ts = R * 0.38;
      if (label.length > 12) ts = R * 0.32;

      textAlign(CENTER, CENTER);
      stroke(0,0,0,180);
      strokeWeight(8);
      fill(255,255,255,245);
      textSize(ts);
      text(label, cx, cy + 6);

      noStroke();
      fill(255,255,255,245);
      text(label, cx, cy + 6);
    }

    // ===== WINNER HEADER (banner + glow) =====
    const by = height * 0.16;

    noStroke();
    rectMode(CENTER);
    fill(255, 0, 200, 70 + pulse*60);
    rect(cx, by, width * 0.72, 62, 18);
    fill(160, 80, 255, 40 + pulse*40);
    rect(cx, by, width * 0.76, 70, 18);

    textAlign(CENTER, CENTER);
    textSize(40);
    stroke(0,0,0,180);
    strokeWeight(10);
    fill(255,255,255,245);
    text("WINNER!", cx, by);
    noStroke();
    fill(255,255,255,245);
    text("WINNER!", cx, by);

    // ===== HANDLE DISPLAY =====
    const hLabel = (b.handle ? "@" + b.handle : ("#" + b.id));
    textSize(24);
    stroke(0,0,0,170);
    strokeWeight(8);
    fill(170, 240, 255, 245);
    text(hLabel, cx, height*0.24);
    noStroke();
    fill(170, 240, 255, 245);
    text(hLabel, cx, height*0.24);

    // ===== FOLLOW CTA =====
    textSize(16);
    stroke(0,0,0,150);
    strokeWeight(6);
    fill(220, 200, 255, 245);
    text("Follow @Zorbi.ai + comment “IN” to enter tomorrow", cx, height*0.29);
    noStroke();
    fill(220, 200, 255, 245);
    text("Follow @Zorbi.ai + comment “IN” to enter tomorrow", cx, height*0.29);
  }

  
  function drawBubbleLabel(label, x, y, r) {
    label = String(label || "");
    let shown = label;
    if (shown.length > 14) shown = shown.slice(0, 13) + "…";

    let ts = r * 0.55;
    if (shown.length > 6) ts = r * 0.42;
    if (shown.length > 10) ts = r * 0.34;

    textAlign(CENTER, CENTER);

    stroke(0, 0, 0, 180);
    strokeWeight(6);
    fill(255,255,255,245);
    textSize(ts);
    text(shown, x, y);

    stroke(255,255,255,90);
    strokeWeight(2);
    fill(255,255,255,245);
    text(shown, x, y);
  }

  class Bubble {
    constructor(id, handle, x, y, r, img) {
      this.id = id;
      this.handle = handle || null;
      this.x = x; this.y = y; this.r = r;
      this.img = img;

      this.v = createVector(random(-1, 1), random(-1,1)).mult(random(0.6, 1.6));
      this.wob = random(TAU);
      this.wobSp = random(0.02, 0.05);

      this.spin = random([-1, 1]) * random(0.8, 1.35);
      this.swirl = random(0.6, 1.4);
    }

    update() {
      const f = p5.Vector.random2D().mult(CFG.wanderForce * CFG.chaos);
      this.v.add(f);

      const cx = width * 0.5;
      const cy = height * 0.60;
      const toC = createVector(cx - this.x, cy - this.y);

      const tangent = createVector(-toC.y, toC.x).normalize()
        .mult(CFG.swirlStrength * this.spin * this.swirl * CFG.chaos);
      this.v.add(tangent);

      if (random() < CFG.swirlJukeChance * CFG.chaos) {
        const j = p5.Vector.random2D().mult(CFG.swirlJukeForce * random(0.7, 1.2));
        this.v.add(j);
      }

      const maxV = CFG.maxSpeed * (0.85 + 0.35 * CFG.chaos);
      if (this.v.mag() > maxV) this.v.setMag(maxV);

      this.x += this.v.x;
      this.y += this.v.y;

      const topBound = height * 0.28;
      if (this.x < this.r) { this.x = this.r; this.v.x *= -1; }
      if (this.x > width - this.r) { this.x = width - this.r; this.v.x *= -1; }
      if (this.y < topBound + this.r) { this.y = topBound + this.r; this.v.y *= -1; }
      if (this.y > height - this.r) { this.y = height - this.r; this.v.y *= -1; }

      this.v.mult(CFG.bounceDamping);
      this.wob += this.wobSp;
    }

    separate(other) {
      const dx = other.x - this.x, dy = other.y - this.y;
      const d = Math.sqrt(dx*dx + dy*dy);
      const minD = this.r + other.r + 8;
      if (d > 0 && d < minD) {
        const overlap = (minD - d) / minD;
        const push = overlap * CFG.separationStrength * (1 + 0.35 * CFG.chaos);
        const nx = dx / d, ny = dy / d;

        this.x -= nx * push * 40; this.y -= ny * push * 40;
        other.x += nx * push * 40; other.y += ny * push * 40;

        this.v.x -= nx * push * 1.2; this.v.y -= ny * push * 1.2;
        other.v.x += nx * push * 1.2; other.v.y += ny * push * 1.2;
      }
    }

    draw() {
      push();
      translate(this.x, this.y);
      const wobble = 1 + sin(this.wob) * 0.03;

      noStroke();
      fill(120, 220, 255, 24);
      circle(0, 0, this.r*2 + CFG.bubbleGlow);

      stroke(190, 245, 255, 110);
      strokeWeight(3);
      fill(255, 255, 255, 14);
      ellipse(0, 0, this.r*2*wobble, this.r*2*(2-wobble));

      if (this.img) {
        drawClippedImageCircle(this.img, 0, 2, this.r*1.55);
      } else {
        const label = this.handle ? ("@" + this.handle) : String(this.id);
        drawBubbleLabel(label, 0, 6, this.r);
      }

      noStroke();
      fill(255,255,255,55);
      ellipse(-this.r*0.28, -this.r*0.32, this.r*0.85, this.r*0.55);

      pop();
    }
  }

  class Projectile {
    constructor(x, y, vx, vy, piercing=false, ricochet=false) {
      this.x=x; this.y=y;
      this.v=createVector(vx, vy);
      this.r=CFG.projectileRadius;
      this.dead=false;
      this.piercing=piercing;
      this.ricochet=ricochet;
      this.hasRicocheted=false;
    }

    update() {
      this.x += this.v.x;
      this.y += this.v.y;

      if (this.y > height + 120 || this.x < -120 || this.x > width + 120) {
        this.dead = true;
        return;
      }

      for (let i = players.length - 1; i >= 0; i--) {
        const b = players[i];
        if (dist(this.x, this.y, b.x, b.y) < b.r + this.r) {
          if (BACKEND_WINNER && b.handle === BACKEND_WINNER && players.length > 1) {
            this.dead = true;
            break;
          }

          popBubble(b);
          players.splice(i, 1);

          if (!this.piercing) {
            this.dead = true;
          } else {
            this.r *= 0.92;
            this.v.mult(0.92);
            if (this.r < 6) this.dead = true;
          }

          if (this.ricochet && !this.hasRicocheted && !this.dead) {
            this.hasRicocheted = true;
            const nv = p5.Vector.random2D().mult(CFG.projectileSpeed*0.85);
            nv.y = abs(nv.y) + 6;
            this.v = nv;
          }
          break;
        }
      }
    }

    draw() {
      noStroke();
      fill(255, 120, 0, 55);
      circle(this.x, this.y, this.r*4.4);
      fill(255, 240, 120, 220);
      circle(this.x, this.y, this.r*1.8);

      stroke(255, 255, 255, 70);
      strokeWeight(3);
      line(this.x, this.y, this.x - this.v.x*2.0, this.y - this.v.y*2.0);
    }
  }

  class Particle {
    constructor(x, y, vx, vy, life, kind='spark') {
      this.x=x; this.y=y;
      this.v=createVector(vx, vy);
      this.life=life;
      this.maxLife=life;
      this.kind=kind;
      this.dead=false;
      this.r=(kind === 'pop') ? random(3,7) : random(2,4);
    }
    update() {
      this.x += this.v.x;
      this.y += this.v.y;
      this.v.mult(0.93);
      this.life -= 1;
      if (this.life <= 0) this.dead = true;
    }
    draw() {
      const a = map(this.life, 0, this.maxLife, 0, 255);
      noStroke();
      if (this.kind === 'pop') fill(255,255,255,a);
      else fill(255,80,240,a);
      circle(this.x, this.y, this.r);
    }
  }

  function popBubble(b) {
    playRandPop();
    playOne(sfxBass, SFX.bass);
    frameShake = max(frameShake, CFG.screenShake*(players.length<=5?1.2:1.0));

    for (let i = 0; i < CFG.popParticles; i++) {
      const v = p5.Vector.random2D().mult(random(2.5, 8.5));
      v.y += 1.2;
      particles.push(new Particle(b.x, b.y, v.x, v.y, CFG.sparkLife, 'spark'));
    }
    for (let i = 0; i < 10; i++) {
      const v = p5.Vector.random2D().mult(random(1.2, 6.2));
      particles.push(new Particle(b.x, b.y, v.x, v.y, CFG.popLife, 'pop'));
    }
  }

  async function reportWinnerToBackend(b) {
    try {
      await fetch(WINNER_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ winner: b.handle || ("#" + b.id), winnerSlot: b.id })
      });
    } catch (e) {}
  }

  
  function pickMimeType() {
    if (!window.MediaRecorder) return null;
    const types = [
      "video/mp4;codecs=avc1.42E01E", // iOS Safari often supports this
      "video/mp4",
      "video/webm;codecs=vp9",
      "video/webm;codecs=vp8",
      "video/webm"
    ];
    for (const t of types) {
      try { if (MediaRecorder.isTypeSupported(t)) return t; } catch(e) {}
    }
    return "";
  }

  function safeFilename(ext) {
    const d = (ROUND_META?.round_date || new Date().toISOString().slice(0,10)).replaceAll("-", "");
    return `zorbi_${d}.${ext}`;
  }

  async function startRecording() {
    try {
      if (!window.MediaRecorder) return; // not supported
      if (recording) return;
      if (!recEnabled) return;

      const cnv = document.querySelector("canvas");
      if (!cnv || !cnv.captureStream) return;

      // Lower FPS for stability on iOS
      const stream = cnv.captureStream(30);
      const mimeType = pickMimeType();
      const opts = { mimeType, videoBitsPerSecond: 2_500_000 };

      recChunks = [];
      mediaRecorder = new MediaRecorder(stream, opts);
      mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size) recChunks.push(e.data); };
      mediaRecorder.onstop = () => {};
      mediaRecorder.start(1000); // collect 1s chunks
      recording = true;

      btnRecEl?.classList.add("recOn");
      updatePanelStatus();
    } catch (e) {
      console.warn("Recording start failed:", e);
    }
  }

  async function stopRecording(captureWinnerHold = true) {
    if (!recording || !mediaRecorder) return;

    // give winner screen a brief moment
    if (captureWinnerHold) await new Promise(r => setTimeout(r, 1200));

    try { mediaRecorder.stop(); } catch (e) {}
    recording = false;
    btnRecEl?.classList.remove("recOn");

    // Build blob
    const mime = mediaRecorder.mimeType || pickMimeType() || "video/webm";
    const blob = new Blob(recChunks, { type: mime });
    const ext = mime.includes("mp4") ? "mp4" : "webm";

    // Free recorder
    mediaRecorder = null;
    recChunks = [];

    if (!blob || blob.size < 1024) {
      updatePanelStatus();
      return;
    }

    // Local download link fallback
    if (lastVideoUrl) URL.revokeObjectURL(lastVideoUrl);
    lastVideoUrl = URL.createObjectURL(blob);

    if (recAutoUpload) {
      await uploadVideo(blob, safeFilename(ext));
    } else {
      // show a toast with a direct download link
      try {
        toastEl.textContent = "Video ready • tap HUD to show UI then long-press to save";
        toastPulse();
      } catch(e) {}
    }

    updatePanelStatus();
  }

  async function uploadVideo(blob, filename) {
    try {
      const fd = new FormData();
      fd.append("video", blob, filename);
      fd.append("round_date", ROUND_META?.round_date || "");
      if (UPLOAD_TOKEN) fd.append("token", UPLOAD_TOKEN);

      const res = await fetch(VIDEO_UPLOAD_URL, { method: "POST", body: fd });
      const data = await res.json().catch(()=>({}));
      if (!res.ok || !data?.ok) throw new Error(data?.error || ("HTTP "+res.status));

      // backend returns a URL you can download/share
      if (data.video_url) {
        toastEl.textContent = "Uploaded • video ready on backend";
        toastPulse();
        // Keep for display
        ROUND_META.video_url = data.video_url;
      }
    } catch (e) {
      console.warn("Upload failed:", e);
      toastEl.textContent = "Upload failed • recording saved locally only";
      toastPulse();
    }
  }


function updatePanelStatus() {
    panelRosterEl.textContent = `Roster: ${CFG.playerCount} entrants`;

    panelZorbEl.textContent = zorbLoaded ? 'Zorb: OK' : 'Zorb: missing';
    panelZorbEl.classList.toggle('ok', zorbLoaded);
    panelZorbEl.classList.toggle('warn', !zorbLoaded);

    panelAudioEl.textContent = audioUnlocked ? 'Audio: unlocked' : 'Audio: locked';
    panelAudioEl.classList.toggle('ok', audioUnlocked);
    panelAudioEl.classList.toggle('warn', !audioUnlocked);

    panelBackendEl.textContent = BACKEND_OK ? `Backend: OK (${CFG.playerCount})` : `Backend: offline`;
    panelBackendEl.classList.toggle('ok', BACKEND_OK);
    panelBackendEl.classList.toggle('bad', !BACKEND_OK);

    // Video status
    const recLabel = recording ? 'REC' : (recEnabled ? 'ready' : 'off');
    const upLabel = recAutoUpload ? 'auto↑' : 'manual';
    const hasUrl = ROUND_META?.video_url ? ' ✓' : '';
    panelVideoEl.textContent = `Video: ${recLabel} • ${upLabel}${hasUrl}`;
    btnRecEl.textContent = recEnabled ? (recording ? 'REC●' : 'Rec') : 'Rec off';
    btnAutoUpEl.textContent = recAutoUpload ? '↑' : '↧';
    panelVideoEl.classList.toggle('purple', recording || (players.length<=5 && simState==='running'));

    enableStart(true);
  }

  function updateHud() {
    const z = zorbLoaded ? `ok` : `MISSING Zorb2.PNG`;
    const a = audioUnlocked ? `unlocked` : `locked`;
    const state = (simState === "setup") ? "SETUP"
      : (simState === "countdown") ? "COUNTDOWN"
      : (simState === "running") ? "RUNNING"
      : "FINISH";
    const cd = (simState === "countdown") ? ` • starts in ${ceil(countdownFrames/60)}s` : '';
    const rd = ROUND_META?.round_date ? ` • ${ROUND_META.round_date}` : '';
    const mode = ROUND_META?.mode ? ` • ${ROUND_META.mode}` : '';
    const backend = BACKEND_OK ? ` • backend OK` : ` • backend offline`;

    // Use textContent (not innerHTML) to reduce DOM churn on iOS Safari
    hudStatusEl.textContent =
      `State: ${state}${rd}${mode}${backend} • Zorb: ${z} • Audio: ${a}` +
      ` • Players: ${CFG.playerCount} • Remaining: ${players.length} • Chaos: ${CFG.chaos.toFixed(2)}${cd}` +
      (paused ? ` • PAUSED` : ``);
  }

  function updatePanelStatusThrottled(force=false) {
    const now = performance.now();
    if (force || now - lastPanelUpdateMs > 800) {
      lastPanelUpdateMs = now;
      updatePanelStatus();
    }
  }

  function updateHudThrottled(force=false) {
    const now = performance.now();
    if (force || now - lastHudUpdateMs > 250) {
      lastHudUpdateMs = now;
      updateHud();
      updatePanelStatusThrottled(false);
    }
  }
  </script>
</body>
</html>
