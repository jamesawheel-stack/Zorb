<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <link rel="icon" type="image/png" href="zorb.png">
  <title>Zorbi – Mobile Full v6.7 (1080x1920 fixed)</title>

  <style>
    :root{
      --bg:#0B0F1F;
      --panel:rgba(0,0,0,0.35);
      --panel2:rgba(0,0,0,0.58);
      --stroke:rgba(255,255,255,0.14);
      --text:rgba(255,255,255,0.92);
      --btn:rgba(255,255,255,0.11);
      --btnHover:rgba(255,255,255,0.18);
      --good:rgba(120,255,170,0.92);
      --warn:rgba(255,210,120,0.92);
      --bad:rgba(255,120,120,0.92);
    }
    html,body{margin:0;padding:0;background:var(--bg);overflow:hidden;height:100%}
    canvas{display:block;margin:0 auto;touch-action:none}

    #hud{
      position:fixed;left:12px;top:12px;z-index:10;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);font-size:12px;line-height:1.25;
      background:var(--panel);border:1px solid var(--stroke);
      padding:10px 12px;border-radius:12px;backdrop-filter:blur(10px);
      max-width:390px;
    }
    #hud b{font-size:13px}
    #hud .tiny{opacity:.78;font-size:11px;margin-top:6px}

    #panel{
      position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
      z-index:30;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--panel2);border:1px solid rgba(255,255,255,0.18);
      padding:18px 18px 14px;border-radius:16px;color:var(--text);
      width:min(92vw,460px);text-align:center;backdrop-filter:blur(12px);
    }
    #panel h1{font-size:18px;margin:0 0 10px}
    #panel p{margin:8px 0;font-size:12px;opacity:.92;line-height:1.35}
    #panel .row{display:flex;gap:10px;justify-content:center;align-items:center;flex-wrap:wrap;margin-top:10px}
    #panel .note{font-size:11px;opacity:.75;margin-top:10px}
    #panel .status{margin-top:10px;font-size:12px;opacity:.95}
    #panel .pill{
      background:rgba(0,0,0,0.55);
      border:1px solid rgba(255,255,255,0.14);
      padding:8px 12px;
      border-radius:999px;
      font-weight:800;
      color:rgba(255,255,255,0.92);
      text-shadow:0 2px 10px rgba(0,0,0,0.6);
    }
    #panel .ok{color:var(--good)} #panel .warn{color:var(--warn)} #panel .bad{color:var(--bad)}

    #controls{
      position:absolute;left:12px;right:12px;bottom:12px;
      padding:12px; border-radius:18px;
      background:rgba(0,0,0,0.42);
      border:1px solid rgba(255,255,255,0.10);
      box-shadow:0 0 0 1px rgba(255,0,255,0.10), 0 18px 40px rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
    }
    .btn{
      background:rgba(0,0,0,0.55);
      color:rgba(255,255,255,0.92);
      border:1px solid rgba(255,255,255,0.18);
      border-radius:14px;
      padding:12px 16px;
      font-weight:800;
      letter-spacing:.2px;
      box-shadow:0 0 0 1px rgba(255,0,255,0.15), 0 8px 24px rgba(0,0,0,0.35);
      text-shadow:0 2px 10px rgba(0,0,0,0.6);
    }
    .btn:active{transform:translateY(1px);background:var(--btnHover)}
    .btn.small{min-width:52px;padding:10px 10px}
    .btn.wide{min-width:110px}
    .btn.primary{border-color:rgba(120,255,170,0.35);background:rgba(120,255,170,0.12)}
    select.btn{
      background:var(--btn);
      color:var(--text);
      border:1px solid rgba(255,255,255,0.18);
      -webkit-appearance:none;
      appearance:none;
    }
    select.btn option{ background:var(--bg); color:var(--text); }
    .hidden{display:none!important}

    #toast{
      position:fixed;left:50%;top:14px;transform:translateX(-50%);
      z-index:40;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      font-size:12px;color:var(--text);
      background:rgba(0,0,0,0.55);border:1px solid rgba(255,255,255,0.14);
      padding:8px 10px;border-radius:999px;backdrop-filter:blur(10px);
      opacity:0;transition:opacity 220ms ease;pointer-events:none;
    }
    #toast.show{opacity:1}
  </style>
</head>

<body>
  <div id="toast">UI shown</div>

  <div id="hud">
    <b>Zorbi – Today’s Round</b>
    <div id="hudStatus">Loading…</div>
    <div class="tiny">Tap background: pause/resume • Tap anywhere when UI hidden: show UI</div>
  </div>

  <div id="panel">
    <h1 id="panelTitle">Load today’s roster</h1>
    <p>Today’s roster supports up to <b id="maxCountLabel">?</b> entrants. Press <b>Start</b> to begin.</p>

    <div class="row">
      <button class="btn wide primary" id="startBtn" type="button">Start Battle</button>
      <button class="btn wide" id="clearBtn" type="button">Reset</button>
    </div>

    <div class="row">
      <button class="btn wide" id="modeBtn" type="button">MODE: LIVE</button>
      <select class="btn wide" id="offlineCountSel">
        <option value="120">OFFLINE: 120</option>
        <option value="250" selected>OFFLINE: 250</option>
        <option value="500">OFFLINE: 500</option>
        <option value="1000">OFFLINE: 1000</option>
        <option value="2500">OFFLINE: 2500</option>
      </select>
    </div>

    <div class="status">
      <span class="pill" id="panelRoster">Roster: …</span>
      <span class="pill" id="panelZorb">Zorb: …</span>
      <span class="pill" id="panelAudio">Audio: …</span>
      <span class="pill" id="panelBackend">Backend: …</span>
    </div>

    <div class="note">After Start: UI hides immediately (and stays hidden all game unless you tap).</div>
  </div>

  <div id="controls">
    <button class="btn wide" id="btnShowPanel" type="button">Roster</button>
    <button class="btn" id="btnPause" type="button">Pause</button>
    <button class="btn" id="btnRestart" type="button">Restart</button>
    <button class="btn wide" id="btnHide" type="button">Hide UI</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/addons/p5.sound.min.js"></script>

  <script>
  // =============================
  // Zorbi v6.7 patches included:
  // 1) FIX: true 1080x1920 canvas + shake no longer crops sides (shake applied to world layer only)
  // 2) FIX: remove weird purple horizontal line (removed bloom "screen" pass + tightened scanlines)
  // 3) FIX: players/round HUD always visible above UI frame
  // 4) FIX: hide UI frame during winner screen
  // 5) PERF: fewer expensive draws when huge; fixed dot fields (prevents 250+ errors)
  // =============================

  const BACKEND_BASE =
    (location.hostname === "localhost" || location.hostname === "127.0.0.1")
      ? "http://localhost:10000"
      : "https://zorb.onrender.com";

  const ROUND_URL  = BACKEND_BASE + "/top50.json";
  const WINNER_URL = BACKEND_BASE + "/round/today/winner";

  let USE_BACKEND = true;
  let OFFLINE_COUNT = 250;

  let ROUND_META = { round_date:null, mode:null, claimed_total:null, finale_count:null, status:null, seed:null, round_number:2 };
  let BACKEND_WINNER = null;
  let BACKEND_OK = false;

  const CFG = {
    fixedW:1080,
    fixedH:1920,
    bgColor:'#0B0F1F',
    vignette:true,
    roundNumber: 2,
    playerCount:50,

    wanderForce:0.16,
    maxSpeed:2.35,
    bounceDamping:0.985,
    separationStrength:0.30,

    swirlStrength:0.16,
    swirlJukeChance:0.010,
    swirlJukeForce:1.55,

    robotScale:0.15,
    robotY:0.16,
    robotHoverAmpY:8,
    robotHoverSpeedY:0.028,
    robotSwayFracX:0.08,
    robotSwaySpeedX:0.018,

    cannonXFrac:[0.34,0.50,0.66],
    cannonYFrac:0.65,

    chargeTime:10,
    fireRate:0.75,
    fireRateFinal:0.34,
    fireRateFinal2:0.20,

    aimJitter:16,
    projectileSpeed:16,
    projectileRadius:10,
    multiElimChance:0.08,
    nearMissChance:0.10,
    ricochetChance:0.06,

    screenShakePop:12,
    screenShakeShot:2.2,

    popParticles:18,   // PERF: slightly reduced
    popLife:24,
    sparkLife:16,
    slowMoFrames:60,
  };

  const PERF = {
    maxSimBubbles: 160,        // expensive physics cap
    dotUpdateStride: 2,
    maxDotDraw: 850,           // PERF: cap draw density
    scanlineStep: 4,           // PERF + cleaner (also helps purple banding)
  };

  const ARENA_PAD = 22;

  // ---------- state ----------
  let zorbImg, zorbLoaded=false;
  let uiFrameImg=null, winnerFrameImg=null;
  let bgImg = null;

  let rosterHandles=[];
  let players=[], projectiles=[], particles=[], stars=[];
  let paused=false, frameShake=0;
  let zorb={ y:0, aimX:0, aimY:0, charge:0, recoil:0, fireCooldown:0, aimMeta:null };

  let simState="setup";
  let countdownFrames=0;
  let countdownLabels = [];
  let lastCountdownSec = -1;

  // dots must have sp/sw/z or draw code can break at 250+
  let extraDots = []; // {id,x,y,r,vx,vy,tw,sp,sw,z,a}

  // Winner / overlays
  let winnerPlayed=false;
  let confetti=[], confettiActive=false, confettiUntilFrame=0;

  // UI
  let hudEl, hudStatusEl, panelEl, toastEl, controlsEl;
  let panelRosterEl, panelZorbEl, panelAudioEl, panelBackendEl, startBtnEl;
  let uiHidden=false, hideTimer=null;
  let lastHudUpdateMs=0, lastPanelUpdateMs=0;

  // Audio
  let audioUnlocked=false;
  let sfxPop=[], sfxWinner, sfxReload, sfxFire, sfxBass, sfxWoosh, sfxTension, sfxMusic;
  const SFX={ master:0.90, pop:0.65, fire:0.65, reload:0.45, bass:0.75, woosh:0.55, tensionMax:0.55, winner:0.95 };
  const MUSIC = { bed:0.18, fadeInMs:900 };

  // ✅ World render layer (shake happens here only, never crops frame/UI)
  let worldG=null;

  function totalRemaining(){ return players.length + extraDots.length; }

  function getDynamicBubbleSize(count){
    if(count<=20)  return {min:62,max:84};
    if(count<=40)  return {min:50,max:70};
    if(count<=60)  return {min:40,max:56};
    if(count<=100) return {min:22,max:32};
    return {min:16,max:22};
  }
  function labelAlphaForRemaining(remaining, r){
    const byCount = constrain(map(remaining, 100, 30, 0, 255), 0, 255);
    const bySize  = constrain(map(r, 18, 34, 0, 255), 0, 255);
    return Math.min(byCount, bySize);
  }

  function startMusicSoft(){
    if(!sfxMusic || !audioUnlocked) return;
    try{
      sfxMusic.stop();
      sfxMusic.setLoop(true);
      sfxMusic.amp(0,0);
      sfxMusic.loop();
      sfxMusic.amp(MUSIC.bed, Math.max(0.2, MUSIC.fadeInMs/1000));
    }catch(_){}
  }
  function stopMusicSoft(){
    if(!sfxMusic) return;
    try{
      sfxMusic.amp(0,0.25);
      setTimeout(()=>{ try{sfxMusic.stop();}catch(_){ } }, 280);
    }catch(_){}
  }

  // ---------- preload ----------
  function preload(){
    zorbImg = loadImage('zorb.png', ()=>{ zorbLoaded=true; }, ()=>{ zorbLoaded=false; console.warn("zorb.png failed"); });
    bgImg = loadImage('background.png', ()=>{}, ()=>{ console.warn("Missing background.png"); });
    uiFrameImg = loadImage('ui_frame.png', ()=>{}, ()=>{ console.warn("Missing ui_frame.png"); });
    winnerFrameImg = loadImage('winnerframe.png', ()=>{}, ()=>{ console.warn("Missing winnerframe.png"); });

    // OPTIONAL: If you later add audio files, load them here with loadSound(...)
    // sfxMusic = loadSound('music.mp3');
    // sfxWoosh = loadSound('woosh.mp3');
    // etc...
  }

  async function setup(){
    createOrResizeCanvas();
    hookUI();
    await loadTodayRound();
    resetSim(true);
    updatePanelStatusThrottled(true);
    updateHudThrottled(true);
  }

  function windowResized(){ createOrResizeCanvas(); }

  // ✅ Fixed internal 1080x1920 + CSS scale to device
  function createOrResizeCanvas(){
    const w = CFG.fixedW, h = CFG.fixedH;
    if(!window._zorbiCanvas){
      window._zorbiCanvas = createCanvas(w, h);
    } else {
      resizeCanvas(w, h);
    }

    // world graphics layer matches exactly (no crop ever)
    worldG = createGraphics(w, h);

    const dpr = window.devicePixelRatio || 2;
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    pixelDensity(isIOS ? Math.min(1.5, dpr) : Math.min(1.75, dpr));

    const scale = Math.min(windowWidth / w, windowHeight / h);
    const c = document.querySelector('canvas');
    if(c){
      c.style.width = Math.floor(w * scale) + "px";
      c.style.height = Math.floor(h * scale) + "px";
    }

    // (re)build stars for background motion
    stars=[];
    for(let i=0;i<120;i++){
      stars.push({x:random(width),y:random(height),r:random(0.8,2.2),tw:random(TAU),sp:random(0.006,0.02)});
    }
  }

  // ---------- backend / roster ----------
  async function loadTodayRound(){
    if(!USE_BACKEND){
      BACKEND_OK = false;
      BACKEND_WINNER = null;
      const finalCount = Math.max(2, Math.min(5000, Number(OFFLINE_COUNT||250)));
      CFG.playerCount = finalCount;

      rosterHandles = Array.from({length: finalCount}, (_,i)=>{
        const n=i+1;
        return (n<=9999) ? ("player"+n) : ("p"+n);
      });

      ROUND_META.round_number = 2;
      document.getElementById("maxCountLabel").textContent = String(CFG.playerCount);
      document.getElementById("panelTitle").textContent = "Load roster (OFFLINE TEST)";
      updateHudThrottled(true);
      updatePanelStatusThrottled(true);
      return true;
    }

    try{
      const ctrl = new AbortController();
      const to = setTimeout(()=>ctrl.abort(), 6500);
      const res = await fetch(ROUND_URL, { cache:"no-store", signal: ctrl.signal });
      clearTimeout(to);
      if(!res.ok) throw new Error("HTTP "+res.status);
      const round = await res.json();

      BACKEND_OK = true;

      const fc = Number(round?.finale_count || (round?.players?.length || 0) || 0);
      const finalCount = Math.max(2, Math.min(100, fc || 50));
      CFG.playerCount = finalCount;

      rosterHandles = Array.isArray(round?.players)
        ? round.players.map(p => (p.handle || ("#" + p.slot)))
        : [];

      BACKEND_WINNER = round?.winner || null;
      ROUND_META.round_number = Number(round?.round_number || round?.round || 2) || 2;
      ROUND_META.round_date = round?.round_date || null;
      ROUND_META.mode = round?.mode || null;

      document.getElementById("maxCountLabel").textContent = String(CFG.playerCount);
      document.getElementById("panelTitle").textContent =
        (ROUND_META?.mode === "live") ? "Load today’s roster (LIVE)" : "Load today’s roster";

      updateHudThrottled(true);
      updatePanelStatusThrottled(true);
      return true;
    }catch(e){
      BACKEND_OK=false;
      document.getElementById("panelTitle").textContent = "Load today’s roster (offline mode)";
      updateHudThrottled(true);
      updatePanelStatusThrottled(true);
      console.warn("Round load failed:", e);
      return false;
    }
  }

  // ---------- UI ----------
  function hookUI(){
    hudEl = document.getElementById('hud');
    hudStatusEl = document.getElementById('hudStatus');
    panelEl = document.getElementById('panel');
    toastEl = document.getElementById('toast');
    controlsEl = document.getElementById('controls');

    panelRosterEl = document.getElementById('panelRoster');
    panelZorbEl = document.getElementById('panelZorb');
    panelAudioEl = document.getElementById('panelAudio');
    panelBackendEl = document.getElementById('panelBackend');

    startBtnEl = document.getElementById('startBtn');

    const modeBtnEl = document.getElementById('modeBtn');
    const offlineSelEl = document.getElementById('offlineCountSel');

    if(modeBtnEl){
      modeBtnEl.addEventListener('click', ()=>{
        USE_BACKEND = !USE_BACKEND;
        modeBtnEl.textContent = USE_BACKEND ? "MODE: LIVE" : "MODE: OFFLINE";
        toastEl.textContent = USE_BACKEND ? "LIVE mode" : "OFFLINE test mode";
        toastPulse();
        bumpUI();
        loadTodayRound();
      });
    }
    if(offlineSelEl){
      offlineSelEl.addEventListener('change', ()=>{
        OFFLINE_COUNT = Number(offlineSelEl.value||250);
        if(!USE_BACKEND){
          toastEl.textContent = `OFFLINE: ${OFFLINE_COUNT}`;
          toastPulse();
          loadTodayRound();
        }
      });
    }

    document.getElementById('btnShowPanel').addEventListener('click', ()=>{ showPanel(true); showUI(true); });
    document.getElementById('btnPause').addEventListener('click', ()=>{ togglePause(); bumpUI(); });
    document.getElementById('btnRestart').addEventListener('click', ()=>{ resetSim(false); showUI(true); showPanel(true); });
    document.getElementById('btnHide').addEventListener('click', ()=>{ setUIHidden(true); });

    document.getElementById('clearBtn').addEventListener('click', ()=>{
      resetSim(true);
      showPanel(true);
      showUI(true);
      updatePanelStatusThrottled(true);
      bumpUI();
    });

    startBtnEl.addEventListener('click', async () => {
      await loadTodayRound();
      resetSim(false);
      beginCountdown();
    });

    // Tap background
    document.body.addEventListener('click', ()=>{
      // attempt to unlock audio context (safe even if no sounds loaded)
      if(!audioUnlocked){
        try{ userStartAudio(); }catch(_){}
        audioUnlocked = true;
        updatePanelStatusThrottled(true);
      }

      if(simState === 'running' || simState === 'countdown'){
        // tap during game: if UI hidden -> show, else toggle pause
        if(!panelEl.classList.contains('hidden')) return;
        if(uiHidden){ showUI(true); bumpUI(); return; }
        togglePause(); bumpUI();
        return;
      }

      // setup screen: just bump UI
      bumpUI();
    }, { passive:true });

    // Stop propagation on buttons
    for(const el of document.querySelectorAll('button, label.btn, select')){
      el.addEventListener('click', (ev)=>ev.stopPropagation());
      el.addEventListener('touchstart', (ev)=>ev.stopPropagation(), { passive:true });
    }

    showPanel(true);
    showUI(true);
  }

  function enableStart(on){ startBtnEl.disabled = !on; }
  function showPanel(show){ panelEl.classList.toggle('hidden', !show); }
  function togglePause(){ if(simState !== "setup") paused = !paused; }

  function beginCountdown(){
    stopMusicSoft();

    showPanel(false);
    if(hideTimer) clearTimeout(hideTimer);
    setUIHidden(true);
    paused = false;

    setTimeout(() => {
      simState = "countdown";
      countdownLabels = (CFG.playerCount >= 25) ? ["3","2","1","GO!"]
                      : (CFG.playerCount >= 10) ? ["READY?","GO!"]
                      : ["GO!"];
      countdownFrames = Math.max(1, Math.floor(countdownLabels.length * 60));
      lastCountdownSec = -1;
    }, 180);
  }

  function showUI(withToast){
    setUIHidden(false);
    if(withToast) toastPulse();
  }
  function setUIHidden(hidden){
    uiHidden=hidden;
    hudEl.classList.toggle('hidden', hidden);
    controlsEl.classList.toggle('hidden', hidden);
  }
  function toastPulse(){
    toastEl.classList.add('show');
    setTimeout(()=>toastEl.classList.remove('show'), 1100);
  }
  function bumpUI(){
    if(hideTimer) clearTimeout(hideTimer);
    setUIHidden(false);
    if(simState === "setup"){
      hideTimer = setTimeout(()=>setUIHidden(true), 1800);
    }
  }

  // ---------- sim ----------
  function resetSim(keepSetupState){
    players=[]; projectiles=[]; particles=[];
    extraDots=[];
    paused=false;
    winnerPlayed=false;
    confetti=[]; confettiActive=false; confettiUntilFrame=0;

    zorb.y = height * CFG.robotY;
    zorb.aimX = width * 0.5;
    zorb.aimY = height * 0.5;
    zorb.charge = 0;
    zorb.recoil = 0;
    zorb.fireCooldown = 0;

    simState = keepSetupState ? "setup" : simState;
    countdownFrames = 0;

    const count = Math.max(2, CFG.playerCount);

    // cap expensive simulation; rest as dots
    const simCount = Math.min(count, PERF.maxSimBubbles);
    const dotCount = Math.max(0, count - simCount);

    const topBound = height*0.30;
    const minY = height*0.32 + 6;
    const maxY = height - ARENA_PAD - 6;
    const marginX = ARENA_PAD + 6;

    // dots (cheap crowd)
    const dotR = (count > 2000) ? 2.0 : (count > 1000) ? 2.4 : (count > 400) ? 2.8 : 3.2;
    for(let i=0;i<dotCount;i++){
      const x = random(marginX, width-marginX);
      const y = random(minY, maxY);
      extraDots.push({
        id: i+1,
        x,y,r:dotR,
        vx: random(-0.9,0.9),
        vy: random(-0.9,0.9),
        tw: random(TAU),
        sp: random(0.006,0.02),
        sw: random(0.6,1.4),
        z: random(0.2,1.0),
        a: 120 + random(60),
      });
    }

    // full bubbles
    for(let i=0;i<simCount;i++){
      const size = getDynamicBubbleSize(simCount);
      const r = random(size.min, size.max);

      let x = width*0.5, y=(topBound+height)*0.5;
      let ok=false;

      for(let attempt=0; attempt<220; attempt++){
        x = random(r+marginX, width-r-marginX);
        y = random(minY+r, maxY-r);
        ok=true;
        for(const other of players){
          const d = dist(x,y, other.x, other.y);
          if(d < r + other.r + 10){ ok=false; break; }
        }
        if(ok) break;
      }

      const handle = rosterHandles[i] || ("#" + (i+1));
      players.push(new Bubble(i+1, handle, x, y, r, random()));
    }

    updatePanelStatusThrottled(true);
    updateHudThrottled(true);
  }

  function getRobotX(){
    const sway = sin(frameCount*CFG.robotSwaySpeedX) * (width*CFG.robotSwayFracX);
    const x = width*0.5 + sway;
    const estHalf = (zorbLoaded && zorbImg) ? (zorbImg.width*CFG.robotScale*0.52) : 120;
    return constrain(x, estHalf+8, width-estHalf-8);
  }

  function draw(){
    if(!paused) step();
    render();
    updateHudThrottled(false);
  }

  function step(){
    zorb.recoil *= 0.86;
    for(const s of stars) s.tw += s.sp;

    // update dots (stride)
    if(extraDots.length){
      const minY = height*0.32 + 6;
      const maxY = height - ARENA_PAD - 6;
      const marginX = ARENA_PAD + 6;

      const stride = Math.max(1, PERF.dotUpdateStride|0);
      const phase = frameCount % stride;

      for(let i=phase;i<extraDots.length;i+=stride){
        const d = extraDots[i];
        d.tw += 0.012;
        const cx=width*0.5, cy=height*0.60;
        const dx=cx-d.x, dy=cy-d.y;
        const inv = 1.0 / (Math.sqrt(dx*dx+dy*dy) + 80);
        d.vx += (-dy)*inv*0.22;
        d.vy += ( dx)*inv*0.22;

        d.x += d.vx;
        d.y += d.vy;

        if(d.x < marginX){ d.x=marginX; d.vx*=-1; }
        if(d.x > width-marginX){ d.x=width-marginX; d.vx*=-1; }
        if(d.y < minY){ d.y=minY; d.vy*=-1; }
        if(d.y > maxY){ d.y=maxY; d.vy*=-1; }

        d.vx *= 0.985;
        d.vy *= 0.985;
      }
    }

    // bubbles physics (O(n^2) but capped to maxSimBubbles)
    for(const b of players) b.update();
    for(let i=0;i<players.length;i++){
      for(let j=i+1;j<players.length;j++) players[i].separate(players[j]);
    }

    for(let i=projectiles.length-1;i>=0;i--){
      projectiles[i].update();
      if(projectiles[i].dead) projectiles.splice(i,1);
    }
    for(let i=particles.length-1;i>=0;i--){
      particles[i].update();
      if(particles[i].dead) particles.splice(i,1);
    }

    if(confettiActive){
      for(let i=confetti.length-1;i>=0;i--){
        confetti[i].update();
        if(confetti[i].dead) confetti.splice(i,1);
      }
      if(frameCount > confettiUntilFrame && confetti.length === 0){
        confettiActive = false;
      }
    }

    if(simState==="countdown"){
      countdownFrames -= 1;
      if(countdownFrames<=0){ simState="running"; countdownFrames=0; }
      return;
    }
    if(simState!=="running") return;

    // fire pacing
    zorb.fireCooldown -= deltaTime/1000;
    if(zorb.fireCooldown<=0 && totalRemaining()>1){
      // simple pacing: faster when big, slower in finals
      const start = Math.max(2, CFG.playerCount);
      const n = totalRemaining();
      const rate = (n<=2) ? CFG.fireRateFinal2 : (n<=5) ? CFG.fireRateFinal : (start>=200) ? 2.2 : (start>=100) ? 1.6 : 1.1;

      if(zorb.charge<=0){
        zorb.charge = CFG.chargeTime;
        const t = pickTarget();
        zorb.aimMeta = t;

        const tx = t.isDot ? t.x : t.bubble.x;
        const ty = t.isDot ? t.y : t.bubble.y;
        zorb.aimX = tx + random(-CFG.aimJitter, CFG.aimJitter);
        zorb.aimY = ty + random(-CFG.aimJitter, CFG.aimJitter);
      }

      zorb.charge -= 1;
      if(zorb.charge<=0){
        fireShot();

        // crowd thinning (cheap)
        if(extraDots.length){
          const batch = (totalRemaining()>1000) ? 6 : (totalRemaining()>400) ? 3 : 1;
          eliminateExtraDots(batch);
        }
        zorb.fireCooldown = 1/(rate);
      }
    }

    // finish: always end on a real bubble (if dots remain)
    if(extraDots.length){
      if(players.length===0){
        const d = extraDots.pop();
        if(d){
          players.push(new Bubble(1, rosterHandles[0] || "#1", d.x, d.y, 44, random()));
        }
      }
      return;
    }

    if(players.length===1){
      simState="finished";
      if(!winnerPlayed){
        winnerPlayed=true;
        spawnConfetti();
        stopMusicSoft();
        setTimeout(()=>startMusicSoft(), 650);
        // optional: reportWinnerToBackend(players[0]) if your endpoint is active
      }
    }
  }

  function pickTarget(){
    const remaining = totalRemaining();
    const dotMode = (extraDots && extraDots.length>0);

    if(dotMode){
      const dotWeight = extraDots.length / Math.max(1, remaining);
      const pDot = constrain(0.35 + dotWeight*0.55, 0.35, 0.90);
      if(random() < pDot){
        const d = random(extraDots);
        if(d) return { isDot:true, id:d.id, x:d.x, y:d.y };
      }
    }

    // avoid backend winner if possible
    const avoidWinner = BACKEND_WINNER && players.length>2;
    const pool = avoidWinner ? players.filter(b=>b.handle !== BACKEND_WINNER) : players;
    if(pool.length===0) return { isDot:false, bubble: random(players) };
    return { isDot:false, bubble: random(pool) };
  }

  function cannonOrigins(){
    const robotX = getRobotX();
    const hoverY = sin(frameCount*CFG.robotHoverSpeedY)*CFG.robotHoverAmpY;

    const sx = CFG.robotScale;
    const imgW = (zorbLoaded && zorbImg) ? zorbImg.width*sx : 320*sx;
    const imgH = (zorbLoaded && zorbImg) ? zorbImg.height*sx : 320*sx;

    const left = robotX - imgW*0.5;
    const top  = (zorb.y + hoverY) - imgH*0.5;

    const y = top + imgH*CFG.cannonYFrac;
    return CFG.cannonXFrac.map(fr => ({ x: left + imgW*fr, y }));
  }

  function fireShot(){
    const origin = random(cannonOrigins());
    const dir = createVector(zorb.aimX-origin.x, zorb.aimY-origin.y).normalize();
    const vel = dir.mult(CFG.projectileSpeed);

    const piercing = random() < CFG.multiElimChance;
    const ricochet = random() < CFG.ricochetChance;

    projectiles.push(new Projectile(
      origin.x, origin.y, vel.x, vel.y, piercing, ricochet,
      (zorb.aimMeta && zorb.aimMeta.isDot) ? zorb.aimMeta.id : null,
      zorb.aimX, zorb.aimY
    ));

    // shake (WORLD ONLY, never moves UI frame/canvas)
    frameShake = Math.max(frameShake, CFG.screenShakeShot*(players.length<=5?1.0:0.8));
  }

  // ---------- render ----------
  function render(){
    // compute shake offsets (applied to worldG only)
    let sx=0, sy=0;
    if(frameShake>0 && !paused){
      sx = random(-frameShake, frameShake);
      sy = random(-frameShake, frameShake);
      frameShake *= 0.86;
    }

    // draw WORLD into offscreen buffer (shake allowed)
    worldG.push();
    worldG.clear();
    worldG.translate(sx, sy);

    // background
    worldG.background(CFG.bgColor);
    if(bgImg){
      worldG.imageMode(CORNER);
      worldG.image(bgImg, 0, 0, width, height);
    }
    if(CFG.vignette) drawVignette(worldG);

    // dots + projectiles + bubbles + zorb + particles
    drawExtraDots(worldG);
    for(const p of projectiles) p.draw(worldG);
    for(const b of players) b.draw(worldG);
    drawZorb(worldG);
    for(const pt of particles) pt.draw(worldG);

    // countdown on world
    if(simState==="countdown") drawCountdown(worldG);

    // winner is rendered on main canvas (no world shake needed there)
    worldG.pop();

    // blit world
    image(worldG, 0, 0);

    // winner screen (covers everything)
    if(simState==="finished" && players.length===1){
      drawWinner(players[0]);
      if(confettiActive) drawConfetti();
      // ✅ Hide ui frame during winner screen (fix #4)
      // (intentionally do NOT draw uiFrameImg here)
      drawArcadeHUD(); // keep PLAYERS/ROUND visible if you want; remove if you don’t
      return;
    }

    // ✅ UI frame overlay (NO shake; perfectly centered 1080x1920)
    drawUIFrameOverlay();

    // ✅ HUD on top of frame so it’s visible (fix #3)
    drawArcadeHUD();

    // scanlines last (but no purple bloom pass)
    drawScanlines();
  }

  function drawUIFrameOverlay(){
    if(!uiFrameImg) return;
    push();
    imageMode(CENTER);
    // cover-fit with tiny bleed
    const iw = uiFrameImg.width || 1;
    const ih = uiFrameImg.height || 1;
    const s  = Math.max(width / iw, height / ih) * 1.01;
    image(uiFrameImg, width/2, height/2, iw*s, ih*s);
    pop();
  }

  function drawVignette(g){
    g.noFill();
    for(let i=0;i<14;i++){
      g.stroke(0,0,0,14);
      g.rect(-i,-i, width+2*i, height+2*i, 22);
    }
  }

  function drawScanlines(){
    noStroke();
    for(let y=0; y<height; y+=PERF.scanlineStep){
      fill(0,0,0,18);
      rect(0,y,width,1);
    }
    // ✅ removed "screen" bloom overlay that can create purple banding/lines on some devices (fix #2)
  }

  // ---------- HUD (players + round) ----------
  function drawArcadeHUD(){
    const padX = 28;
    const y = 22;
    const h = 54;
    const w = width - padX*2;

    noStroke();
    fill(0,0,0,110);
    rect(padX, y, w, h, 18);

    stroke(255,0,200,140);
    strokeWeight(2);
    line(padX+18, y+h-2, padX+w-18, y+h-2);
    noStroke();

    const total = Math.max(1, CFG.playerCount);
    const remaining = totalRemaining();
    const roundNo = (ROUND_META && ROUND_META.round_number) || CFG.roundNumber || 1;

    textFont("system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif");
    textSize(18);
    fill(255,255,255,230);

    textAlign(LEFT, CENTER);
    text(`PLAYERS ${remaining}/${total}`, padX+18, y + h/2);

    textAlign(RIGHT, CENTER);
    text(`ROUND ${roundNo}`, padX + w - 18, y + h/2);
  }

  // ---------- countdown ----------
  function drawCountdown(g){
    const secLeft = ceil(countdownFrames/60);
    const idx = (countdownLabels && countdownLabels.length) ? (countdownLabels.length - secLeft) : 0;
    const label = (countdownLabels && countdownLabels.length)
      ? countdownLabels[constrain(idx, 0, countdownLabels.length-1)]
      : String(secLeft);

    if(secLeft !== lastCountdownSec){
      lastCountdownSec = secLeft;
      // minimal shake; still world-only so it won't cut frame
      frameShake = max(frameShake, 2.0);
    }

    g.noStroke();
    g.fill(0,0,0,120);
    g.rect(0,0,width,height);

    const phase = (countdownFrames % 60) / 60;
    const bounce = 1 + 0.22 * pow(1 - phase, 2);

    const cx = width * 0.5;
    const cy = height * 0.50;

    g.push();
    g.translate(cx, cy);
    g.scale(bounce);

    g.textAlign(CENTER,CENTER);
    g.textSize(label === "GO!" ? 96 : (label === "READY?" ? 74 : 86));
    g.fill(255,255,255,255);
    g.text(label, 0, 0);

    g.stroke(255,255,255,90);
    g.strokeWeight(3);
    g.noFill();
    g.text(label,  0, 0);

    g.pop();
  }

  // ---------- dots ----------
  function drawExtraDots(g){
    if(!extraDots || extraDots.length===0) return;

    const MAX_DRAW = PERF.maxDotDraw;
    const step = max(1, floor(extraDots.length / MAX_DRAW));

    g.noStroke();
    for(let i=0;i<extraDots.length;i+=step){
      const d = extraDots[i];
      d.tw += (d.sp || 0.012);

      const z = d.z ?? 0.5;
      const tw = (sin(d.tw)*0.5+0.5);
      const r = lerp(1.0, 2.4, z);
      const a = lerp(45, 165, z) + tw*55;

      g.fill(210,230,255, a);
      g.circle(d.x, d.y, r);
    }
  }

  function eliminateExtraDots(batch){
    if(!extraDots.length) return;
    const n = min(batch, extraDots.length);
    for(let k=0;k<n;k++){
      const idx = int(random(extraDots.length));
      extraDots[idx] = extraDots[extraDots.length-1];
      extraDots.pop();
    }
  }

  // ---------- zorb ----------
  function drawZorb(g){
    const robotX = getRobotX();
    const hoverY = sin(frameCount*CFG.robotHoverSpeedY)*CFG.robotHoverAmpY;
    const scaleAmt = CFG.robotScale*(1 + zorb.recoil*0.01);

    if(zorbLoaded && zorbImg){
      g.push();
      g.imageMode(CENTER);
      g.image(zorbImg, robotX, zorb.y+hoverY, zorbImg.width*scaleAmt, zorbImg.height*scaleAmt);
      g.pop();
    }else{
      g.push();
      g.translate(robotX, zorb.y+hoverY);
      g.noStroke();
      g.fill(80,240,220,210); g.ellipse(0,0,210,80);
      g.fill(255,0,200,55); g.ellipse(0,0,260,110);
      g.pop();
    }
  }

  // ---------- winner screen ----------
  function drawWinner(b){
    background(6,4,12);
    if(bgImg){
      imageMode(CORNER);
      image(bgImg, 0, 0, width, height);
    }

    if(winnerFrameImg){
      push();
      imageMode(CENTER);
      const iw = winnerFrameImg.width || 1;
      const ih = winnerFrameImg.height || 1;
      const s  = Math.max(width / iw, height / ih) * 1.01;
      image(winnerFrameImg, width/2, height/2, iw*s, ih*s);
      pop();
    }

    const nameRaw = (b && b.handle) ? ("@" + b.handle) : String(b?.id ?? "WINNER");
    const nameX = width * 0.50;
    const nameY = height * 0.44;
    const maxW  = width * 0.78;

    textAlign(CENTER, CENTER);
    let ts = min(64, width*0.10);
    textSize(ts);
    while(textWidth(nameRaw) > maxW && ts > 22){
      ts -= 2; textSize(ts);
    }

    drawingContext.save();
    drawingContext.shadowBlur = 26;
    drawingContext.shadowColor = "rgba(255,180,60,0.75)";
    stroke(0,0,0,220);
    strokeWeight(10);
    fill(255);
    text(nameRaw, nameX, nameY);
    drawingContext.restore();

    textSize(18);
    drawingContext.save();
    drawingContext.shadowBlur = 18;
    drawingContext.shadowColor = "rgba(160,80,255,0.75)";
    fill(230, 210, 255, 240);
    text('Follow @Zorbi.ai + comment "IN" to enter tomorrow', width*0.5, height*0.68);
    drawingContext.restore();
  }

  // ---------- confetti ----------
  class ConfettiPiece{
    constructor(x,y){
      this.x=x; this.y=y;
      this.vx=random(-2.6,2.6);
      this.vy=random(3.2,8.4);
      this.ang=random(TAU);
      this.spin=random(-0.25,0.25);
      this.w=random(6,12);
      this.h=random(10,18);
      this.life=random(120,220);
      this.dead=false;
      this.c = random([
        [255, 0, 200],
        [160, 80, 255],
        [120, 220, 255],
        [255, 240, 120],
        [120, 255, 170],
        [255, 120, 120]
      ]);
    }
    update(){
      this.x += this.vx;
      this.y += this.vy;
      this.vy += 0.06;
      this.vx *= 0.992;
      this.ang += this.spin;
      this.life -= 1;
      if(this.y > height + 50 || this.life <= 0) this.dead=true;
    }
    draw(){
      push();
      translate(this.x, this.y);
      rotate(this.ang);
      noStroke();
      fill(this.c[0], this.c[1], this.c[2], 220);
      rectMode(CENTER);
      rect(0,0,this.w,this.h,2);
      pop();
    }
  }

  function spawnConfetti(){
    confetti = [];
    confettiActive = true;
    confettiUntilFrame = frameCount + 260;
    const burst = 150;
    for(let i=0;i<burst;i++){
      const x = random(10, width-10);
      const y = random(-60, -10);
      confetti.push(new ConfettiPiece(x,y));
    }
  }
  function drawConfetti(){
    for(const c of confetti){
      c.draw();
      c.update();
    }
    confetti = confetti.filter(c=>!c.dead);
    if(frameCount > confettiUntilFrame && confetti.length === 0){
      confettiActive = false;
    }
  }

  // ---------- status ----------
  function updatePanelStatus(){
    panelRosterEl.textContent = `Roster: ${CFG.playerCount} entrants`;

    panelZorbEl.textContent = zorbLoaded ? "Zorb: OK" : "Zorb: missing";
    panelZorbEl.classList.toggle('ok', zorbLoaded);
    panelZorbEl.classList.toggle('warn', !zorbLoaded);

    panelAudioEl.textContent = audioUnlocked ? "Audio: unlocked" : "Audio: locked";
    panelAudioEl.classList.toggle('ok', audioUnlocked);
    panelAudioEl.classList.toggle('warn', !audioUnlocked);

    panelBackendEl.textContent = USE_BACKEND ? (BACKEND_OK ? `Backend: OK (${CFG.playerCount})` : "Backend: offline")
                                            : `Mode: OFFLINE (${CFG.playerCount})`;
    panelBackendEl.classList.toggle('ok', (!USE_BACKEND) || BACKEND_OK);
    panelBackendEl.classList.toggle('bad', USE_BACKEND && !BACKEND_OK);

    enableStart(true);
  }

  function updateHud(){
    const z = zorbLoaded ? "ok" : "MISSING zorb.png";
    const a = audioUnlocked ? "unlocked" : "locked";
    const state =
      (simState==="setup") ? "SETUP" :
      (simState==="countdown") ? "COUNTDOWN" :
      (simState==="running") ? "RUNNING" : "FINISH";

    const rd = ROUND_META?.round_date ? ` • ${ROUND_META.round_date}` : "";
    const mode = ROUND_META?.mode ? ` • ${ROUND_META.mode}` : "";
    const backend = BACKEND_OK ? " • backend OK" : " • backend offline";

    hudStatusEl.textContent =
      `State: ${state}${rd}${mode}${backend} • Zorb: ${z} • Audio: ${a}` +
      ` • Players: ${CFG.playerCount} • Remaining: ${totalRemaining()}` +
      (paused ? " • PAUSED" : "");
  }

  function updatePanelStatusThrottled(force=false){
    const now = performance.now();
    if(force || now - lastPanelUpdateMs > 800){
      lastPanelUpdateMs = now;
      updatePanelStatus();
    }
  }
  function updateHudThrottled(force=false){
    const now = performance.now();
    if(force || now - lastHudUpdateMs > 250){
      lastHudUpdateMs = now;
      updateHud();
      updatePanelStatusThrottled(false);
    }
  }

  // ---------- classes ----------
  function drawBubbleLabel(g, label, x, y, r, alpha){
    label = String(label||"");
    let shown = label;
    if(shown.length>14) shown = shown.slice(0,13)+"…";

    let ts = r*0.55;
    if(shown.length>6) ts = r*0.42;
    if(shown.length>10) ts = r*0.34;

    g.textAlign(CENTER,CENTER);
    const a = (alpha==null)?255:alpha;
    g.stroke(0,0,0, min(200, a*0.85)); g.strokeWeight(6);
    g.fill(255,255,255, min(255, a)); g.textSize(ts);
    g.text(shown, x, y);

    g.stroke(255,255,255, min(140, a*0.45)); g.strokeWeight(2);
    g.fill(255,255,255, min(255, a));
    g.text(shown, x, y);
  }

  class Bubble{
    constructor(id, handle, x, y, r, rSeed=0.5){
      this.id=id;
      this.handle=handle||null;
      this.x=x; this.y=y; this.r=r;
      this.rSeed = rSeed;

      this.v=createVector(random(-1,1), random(-1,1)).mult(random(0.6,1.6));
      this.wob=random(TAU);
      this.wobSp=random(0.02,0.05);

      this.spin=random([-1,1])*random(0.8,1.35);
      this.swirl=random(0.6,1.4);

      this.glareOx = random(-0.36, -0.12);
      this.glareOy = random(-0.46, -0.18);
      this.glareW  = random(0.65, 1.05);
      this.glareH  = random(0.38, 0.70);
      this.glareA  = random(40, 78);
    }

    update(){
      const size = getDynamicBubbleSize(players.length);
      const targetR = lerp(size.min, size.max, this.rSeed);
      this.r = lerp(this.r, targetR, 0.08);

      const f = p5.Vector.random2D().mult(0.16);
      this.v.add(f);

      const cx=width*0.5, cy=height*0.60;
      const toC=createVector(cx-this.x, cy-this.y);
      const tangent=createVector(-toC.y, toC.x).normalize().mult(CFG.swirlStrength*this.spin*this.swirl);
      this.v.add(tangent);

      const maxV = CFG.maxSpeed;
      if(this.v.mag()>maxV) this.v.setMag(maxV);

      this.x += this.v.x;
      this.y += this.v.y;

      const topBound = height*0.28 + ARENA_PAD;
      if(this.x < ARENA_PAD + this.r){ this.x=ARENA_PAD + this.r; this.v.x*=-1; }
      if(this.x > width-ARENA_PAD-this.r){ this.x=width-ARENA_PAD-this.r; this.v.x*=-1; }
      if(this.y < topBound+this.r+4){ this.y=topBound+this.r+4; this.v.y*=-1; }
      if(this.y > height-ARENA_PAD-this.r){ this.y=height-ARENA_PAD-this.r; this.v.y*=-1; }

      this.v.mult(CFG.bounceDamping);
      this.wob += this.wobSp;
    }

    separate(other){
      const dx=other.x-this.x, dy=other.y-this.y;
      const d=Math.sqrt(dx*dx+dy*dy);
      const minD=this.r+other.r+8;
      if(d>0 && d<minD){
        const overlap=(minD-d)/minD;
        const push=overlap*CFG.separationStrength;
        const nx=dx/d, ny=dy/d;

        this.x -= nx*push*40; this.y -= ny*push*40;
        other.x += nx*push*40; other.y += ny*push*40;

        this.v.x -= nx*push*1.2; this.v.y -= ny*push*1.2;
        other.v.x += nx*push*1.2; other.v.y += ny*push*1.2;
      }
    }

    draw(g){
      g.push();
      g.translate(this.x,this.y);
      const wobble = 1 + sin(this.wob)*0.03;

      g.noStroke();
      g.fill(120,220,255,24);
      g.circle(0,0, this.r*2 + 18);

      g.stroke(190,245,255,110);
      g.strokeWeight(3);
      g.fill(255,255,255,14);
      g.ellipse(0,0, this.r*2*wobble, this.r*2*(2-wobble));

      const label = this.handle ? ("@"+this.handle) : String(this.id);
      const la = labelAlphaForRemaining(players.length, this.r);
      if(la > 2) drawBubbleLabel(g, label, 0, 6, this.r, la);

      g.noStroke();
      g.fill(255,255,255,this.glareA);
      g.ellipse(this.r*this.glareOx, this.r*this.glareOy, this.r*this.glareW, this.r*this.glareH);

      g.pop();
    }
  }

  class Projectile{
    constructor(x,y,vx,vy,piercing=false,ricochet=false,dotId=null,tx=null,ty=null){
      this.x=x; this.y=y;
      this.v=createVector(vx,vy);
      this.r=CFG.projectileRadius;
      this.dead=false;
      this.piercing=piercing;
      this.ricochet=ricochet;
      this.hasRicocheted=false;
      this.dotId = dotId;
      this.tx = tx;
      this.ty = ty;
    }

    update(){
      this.x += this.v.x;
      this.y += this.v.y;

      if(this.y > height+120 || this.x < -120 || this.x > width+120){
        this.dead=true; return;
      }

      for(let i=players.length-1;i>=0;i--){
        const b=players[i];
        if(dist(this.x,this.y,b.x,b.y) < b.r + this.r){
          // optionally protect backend winner
          if(BACKEND_WINNER && b.handle === BACKEND_WINNER && players.length>1){
            this.dead=true; break;
          }

          popBubble(b);
          players.splice(i,1);

          if(!this.piercing){
            this.dead=true;
          }else{
            this.r *= 0.92;
            this.v.mult(0.92);
            if(this.r < 6) this.dead=true;
          }

          if(this.ricochet && !this.hasRicocheted && !this.dead){
            this.hasRicocheted=true;
            const nv=p5.Vector.random2D().mult(CFG.projectileSpeed*0.85);
            nv.y = abs(nv.y) + 6;
            this.v = nv;
          }
          break;
        }
      }
    }

    draw(g){
      g.noStroke();
      g.fill(255,120,0,55); g.circle(this.x,this.y,this.r*4.4);
      g.fill(255,240,120,220); g.circle(this.x,this.y,this.r*1.8);
      g.stroke(255,255,255,70); g.strokeWeight(3);
      g.line(this.x,this.y, this.x - this.v.x*2.0, this.y - this.v.y*2.0);
    }
  }

  class Particle{
    constructor(x,y,vx,vy,life,kind='spark'){
      this.x=x; this.y=y;
      this.v=createVector(vx,vy);
      this.life=life; this.maxLife=life;
      this.kind=kind;
      this.dead=false;
      this.r=(kind==='pop') ? random(3,7) : random(2,4);
    }
    update(){
      this.x += this.v.x;
      this.y += this.v.y;
      this.v.mult(0.93);
      this.life -= 1;
      if(this.life<=0) this.dead=true;
    }
    draw(g){
      const a = map(this.life, 0, this.maxLife, 0, 255);
      g.noStroke();
      if(this.kind==='pop') g.fill(255,255,255,a);
      else g.fill(255,80,240,a);
      g.circle(this.x,this.y,this.r);
    }
  }

  function popBubble(b){
    frameShake = max(frameShake, CFG.screenShakePop*(players.length<=5?1.2:1.0));

    for(let i=0;i<CFG.popParticles;i++){
      const v=p5.Vector.random2D().mult(random(2.5,8.5));
      v.y += 1.2;
      particles.push(new Particle(b.x,b.y,v.x,v.y,CFG.sparkLife,'spark'));
    }
    for(let i=0;i<8;i++){
      const v=p5.Vector.random2D().mult(random(1.2,6.2));
      particles.push(new Particle(b.x,b.y,v.x,v.y,CFG.popLife,'pop'));
    }
  }

  // ---------- boot ----------
  </script>
</body>
</html>
