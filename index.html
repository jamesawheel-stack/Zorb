<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <link rel="icon" type="image/png" href="Zorb2.PNG">
  <title>Zorbi – Mobile Full v5.9</title>
  <style>
    :root{
      --bg:#0B0F1F;
      --panel:rgba(0,0,0,0.35);
      --panel2:rgba(0,0,0,0.58);
      --stroke:rgba(255,255,255,0.14);
      --text:rgba(255,255,255,0.92);
      --btn:rgba(255,255,255,0.11);
      --btnHover:rgba(255,255,255,0.18);
      --good:rgba(120,255,170,0.92);
      --warn:rgba(255,210,120,0.92);
      --bad:rgba(255,120,120,0.92);
    }
    html,body{margin:0;padding:0;background:var(--bg);overflow:hidden;height:100%}
    canvas{display:block;margin:0 auto;touch-action:none}

    /* Finale border glow overlay (matches CANVAS bounds, not full viewport) */
    #finalGlow{
      position:fixed;
      pointer-events:none;
      z-index:6; /* above canvas, below hud/panel/controls */
      opacity:0;
      transition:opacity 240ms ease;
      border-radius:22px;
      box-shadow:
        0 0 0 3px rgba(180, 70, 255, 0.0) inset,
        0 0 32px rgba(180, 70, 255, 0.0),
        0 0 90px rgba(255, 0, 200, 0.0);
    }
    #finalGlow.on{opacity:1}

    #hud{
      position:fixed;left:12px;top:12px;z-index:10;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);font-size:12px;line-height:1.25;
      background:var(--panel);border:1px solid var(--stroke);
      padding:10px 12px;border-radius:12px;backdrop-filter:blur(10px);
      max-width:390px;
    }
    #hud b{font-size:13px}
    #hud .tiny{opacity:.78;font-size:11px;margin-top:6px}

    #panel{
      position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
      z-index:30;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--panel2);border:1px solid rgba(255,255,255,0.18);
      padding:18px 18px 14px;border-radius:16px;color:var(--text);
      width:min(92vw,460px);text-align:center;backdrop-filter:blur(12px);
    }
    #panel h1{font-size:18px;margin:0 0 10px}
    #panel p{margin:8px 0;font-size:12px;opacity:.92;line-height:1.35}
    #panel .row{display:flex;gap:10px;justify-content:center;align-items:center;flex-wrap:wrap;margin-top:10px}
    #panel .note{font-size:11px;opacity:.75;margin-top:10px}
    #panel .status{margin-top:10px;font-size:12px;opacity:.95}
    #panel .pill{display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,0.16);background:rgba(255,255,255,0.08)}
    #panel .ok{color:var(--good)} #panel .warn{color:var(--warn)} #panel .bad{color:var(--bad)}

    #controls{
      position:fixed;left:50%;bottom:14px;transform:translateX(-50%);
      z-index:25;display:flex;gap:10px;padding:10px;border-radius:18px;
      background:var(--panel2);border:1px solid rgba(255,255,255,0.16);
      backdrop-filter:blur(14px);
      user-select:none;-webkit-user-select:none;touch-action:manipulation;
    }
    .btn{
      appearance:none;border:1px solid rgba(255,255,255,0.18);
      background:var(--btn);color:var(--text);
      padding:10px 12px;border-radius:14px;font-size:13px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      cursor:pointer;min-width:64px;
    }
    .btn:active{transform:translateY(1px);background:var(--btnHover)}
    .btn.small{min-width:52px;padding:10px 10px}
    .btn.wide{min-width:110px}
    .btn.primary{border-color:rgba(120,255,170,0.35);background:rgba(120,255,170,0.12)}
    .pill.purple{border-color:rgba(180,100,255,0.40);box-shadow:0 0 18px rgba(180,100,255,0.25)}
    .hidden{display:none!important}

    #toast{
      position:fixed;left:50%;top:14px;transform:translateX(-50%);
      z-index:40;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      font-size:12px;color:var(--text);
      background:rgba(0,0,0,0.55);border:1px solid rgba(255,255,255,0.14);
      padding:8px 10px;border-radius:999px;backdrop-filter:blur(10px);
      opacity:0;transition:opacity 220ms ease;pointer-events:none;
    }
    #toast.show{opacity:1}
  </style>
</head>
<body>
  <div id="toast">UI shown • will auto-hide for recording</div>
  <div id="finalGlow"></div>

  <div id="hud">
    <b>Zorbi – Today’s Round</b>
    <div id="hudStatus">Loading…</div>
    <div class="tiny">Tap background: pause/resume • Tap anywhere when UI hidden: show UI</div>
  </div>

  <div id="panel">
    <h1 id="panelTitle">Load today’s roster</h1>
    <p>Today’s roster supports up to <b id="maxCountLabel">?</b> entrants. Press <b>Start</b> to begin the countdown.</p>

    <div class="row">
      <button class="btn wide primary" id="startBtn" type="button">Start Battle</button>
      <button class="btn wide" id="clearBtn" type="button">Reset</button>
    </div>

    <div class="status">
      <span class="pill" id="panelRoster">Roster: …</span>
      <span class="pill" id="panelZorb">Zorb: …</span>
      <span class="pill" id="panelAudio">Audio: …</span>
      <span class="pill" id="panelBackend">Backend: …</span>
    </div>

    <div class="note">Tip: after you press Start, the UI auto-hides in ~2s for clean recording.</div>
  </div>

  <div id="controls">
    <button class="btn wide" id="btnShowPanel" type="button">Roster</button>
    <button class="btn" id="btnPause" type="button">Pause</button>
    <button class="btn" id="btnRestart" type="button">Restart</button>
    <button class="btn small" id="btnChaosDown" type="button">–</button>
    <button class="btn small" id="btnChaosUp" type="button">+</button>
    <button class="btn wide" id="btnHide" type="button">Hide UI</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/addons/p5.sound.min.js"></script>

  <script>
  const BACKEND_BASE =
    (location.hostname === "localhost" || location.hostname === "127.0.0.1")
      ? "http://localhost:10000"
      : "https://zorb.onrender.com";

  const ROUND_URL        = BACKEND_BASE + "/top50.json";
  const WINNER_URL       = BACKEND_BASE + "/round/today/winner";

  let UPLOAD_TOKEN = null;

  let ROUND_META = { round_date:null, mode:null, claimed_total:null, finale_count:null, status:null, seed:null, video_url:null };
  let BACKEND_WINNER = null;
  let BACKEND_OK = false;

  const CFG = {
    aspectW:9, aspectH:16,
    baseHeight:1280,
    bgColor:'#0B0F1F',
    vignette:true,

    playerCount:50,
    bubbleMinR:42,
    bubbleMaxR:58,
    bubbleGlow:18,

    wanderForce:0.16,
    maxSpeed:2.35,
    bounceDamping:0.985,
    separationStrength:0.30,

    swirlStrength:0.16,
    swirlJukeChance:0.010,
    swirlJukeForce:1.55,

    robotScale:0.15,
    robotY:0.12,
    robotHoverAmpY:8,
    robotHoverSpeedY:0.028,
    robotSwayFracX:0.08,
    robotSwaySpeedX:0.018,

    cannonXFrac:[0.34,0.50,0.66],
    cannonYFrac:0.65,

    chargeTime:10,
    fireRate:0.75,
    fireRateFinal:0.34,
    fireRateFinal2:0.20,

    aimJitter:16,
    projectileSpeed:16,
    projectileRadius:10,

    chaos:1.0,
    multiElimChance:0.08,
    nearMissChance:0.10,
    ricochetChance:0.06,

    // shake: keep pops punchy; keep shots subtle
    screenShakePop:12,
    screenShakeShot:2.2,

    popParticles:22,
    popLife:26,
    sparkLife:18,
    slowMoFrames:60,

    countdownSec:3,
  };

  function getDynamicBubbleSize(count){
    if(count<=30) return {min:50,max:68};
    if(count<=60) return {min:42,max:58};
    if(count<=80) return {min:34,max:46};
    return {min:28,max:38};
  }

  let audioUnlocked=false;
  let sfxPop=[], sfxWinner, sfxReload, sfxFire, sfxBass, sfxWoosh, sfxTension;
  let tensionTarget=0, tensionVol=0, winnerPlayed=false;
  let reloadTimer=null;

  const SFX={ master:0.90, pop:0.65, fire:0.65, reload:0.45, bass:0.75, woosh:0.55, tensionMax:0.55, winner:0.95 };

  let zorbImg, zorbLoaded=false;
  let rosterHandles=[];
  let players=[], projectiles=[], particles=[], stars=[];
  let paused=false, frameShake=0;
  let zorb={ y:0, aimX:0, aimY:0, charge:0, recoil:0, fireCooldown:0 };
  let simState="setup";
  let countdownFrames=0;

  let hudEl, hudStatusEl, panelEl, toastEl, controlsEl;
  let panelRosterEl, panelZorbEl, panelAudioEl, panelBackendEl, panelVideoEl, startBtnEl;
  let finalGlowEl;

  let uiHidden=false, hideTimer=null;

  // iOS stability / throttles
  let lastHudUpdateMs=0;
  let lastPanelUpdateMs=0;
  let wakeLock=null;

  // reload SFX timing
  let lastReloadSfxAt=0;

  async function loadTodayRound(){
    try{
      const ctrl = new AbortController();
      const to = setTimeout(()=>ctrl.abort(), 6500);
      const res = await fetch(ROUND_URL, { cache:"no-store", signal: ctrl.signal });
      clearTimeout(to);
      if(!res.ok) throw new Error("HTTP "+res.status);
      const round = await res.json();

      BACKEND_OK = true;

      const fc = Number(round?.finale_count || (round?.players?.length || 0) || 0);
      const finalCount = Math.max(2, Math.min(100, fc || 50));
      CFG.playerCount = finalCount;

      rosterHandles = Array.isArray(round?.players)
        ? round.players.map(p => (p.handle || ("#" + p.slot)))
        : [];

      BACKEND_WINNER = round?.winner || null;
      ROUND_META = {
        round_date: round?.round_date || null,
        mode: round?.mode || null,
        claimed_total: round?.claimed_total ?? null,
        finale_count: round?.finale_count ?? finalCount,
        status: round?.status || null,
        seed: round?.seed ?? null,
      };

      UPLOAD_TOKEN = round?.upload_token || null;

      document.getElementById("maxCountLabel").textContent = String(CFG.playerCount);
      document.getElementById("panelTitle").textContent =
        (ROUND_META?.mode === "live") ? "Load today’s roster (LIVE)" : "Load today’s roster";

      updateHudThrottled(true);
      updatePanelStatusThrottled(true);
      return true;
    }catch(e){
      BACKEND_OK=false;
      document.getElementById("maxCountLabel").textContent = String(CFG.playerCount);
      document.getElementById("panelTitle").textContent = "Load today’s roster (offline mode)";
      updateHudThrottled(true);
      updatePanelStatusThrottled(true);
      console.warn("Round load failed:", e);
      return false;
    }
  }

  function preload(){
    zorbImg = loadImage('Zorb2.PNG?v=4',
      ()=>{ zorbLoaded=true; },
      ()=>{ zorbLoaded=false; console.warn("Zorb failed to load"); }
    );
    sfxPop = [ loadSound('pop1.mp3'), loadSound('pop2.mp3'), loadSound('pop3.mp3'), loadSound('pop4.mp3') ];
    sfxWinner  = loadSound('winner.mp3');
    sfxReload  = loadSound('reload.mp3');
    sfxFire    = loadSound('fire.mp3');
    sfxBass    = loadSound('bass.wav');
    sfxWoosh   = loadSound('woosh.wav');
    sfxTension = loadSound('tension.wav');
  }

  async function setup(){
    createOrResizeCanvas();
    hookUI();
    await loadTodayRound();
    resetSim(true);
    updateCanvasGlowBounds(true);
    updatePanelStatusThrottled(true);
    updateHudThrottled(true);
  }

  function windowResized(){
    createOrResizeCanvas();
    updateCanvasGlowBounds(true);
  }

  function createOrResizeCanvas(){
  const targetH = Math.min(windowHeight, CFG.baseHeight);
  const targetW = targetH * (CFG.aspectW/CFG.aspectH);
  const w = Math.min(windowWidth, targetW);
  const h = w * (CFG.aspectH/CFG.aspectW);
  createCanvas(Math.floor(w), Math.floor(h));

  const dpr = window.devicePixelRatio || 2;
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  const pd = isIOS ? Math.min(1.5, dpr) : Math.min(2, dpr);
  pixelDensity(pd);

  stars=[];
  for(let i=0;i<120;i++){
    stars.push({x:random(width),y:random(height),r:random(0.8,2.2),tw:random(TAU),sp:random(0.006,0.02)});
  }
}

  function hookUI(){
    hudEl = document.getElementById('hud');
    hudStatusEl = document.getElementById('hudStatus');
    panelEl = document.getElementById('panel');
    toastEl = document.getElementById('toast');
    controlsEl = document.getElementById('controls');
    finalGlowEl = document.getElementById('finalGlow');

    panelRosterEl = document.getElementById('panelRoster');
    panelZorbEl = document.getElementById('panelZorb');
    panelAudioEl = document.getElementById('panelAudio');
    panelBackendEl = document.getElementById('panelBackend');

    startBtnEl = document.getElementById('startBtn');

    document.getElementById('btnShowPanel').addEventListener('click', ()=>{ showPanel(true); showUI(true); });
    document.getElementById('btnPause').addEventListener('click', ()=>{ togglePause(); bumpUI(); });
    document.getElementById('btnRestart').addEventListener('click', ()=>{ resetSim(false); showUI(true); showPanel(true); });
    document.getElementById('btnChaosDown').addEventListener('click', ()=>{ CFG.chaos = max(0.35, CFG.chaos-0.15); bumpUI(); });
    document.getElementById('btnChaosUp').addEventListener('click', ()=>{ CFG.chaos = min(3.0, CFG.chaos+0.15); bumpUI(); });
    document.getElementById('btnHide').addEventListener('click', ()=>{ setUIHidden(true); });

    document.getElementById('clearBtn').addEventListener('click', ()=>{
      resetSim(true);
      showPanel(true);
      showUI(true);
      updatePanelStatusThrottled(true);
      bumpUI();
    });

    startBtnEl.addEventListener('click', async () => {
      //Always refresh today's round first
      await loadTodayRound();

      //Build players from backend roster
      resetSim(false);

      //Begin game
      beginCountdown();
    });

    document.addEventListener('visibilitychange', ()=>{
      if(document.visibilityState === 'visible') onReturnToApp();
    });
    window.addEventListener('pageshow', ()=> onReturnToApp());
    window.addEventListener('focus', ()=> onReturnToApp());

    document.body.addEventListener('click', ()=>{
      resumeAudioNow();
      if(simState === 'running' || simState === 'countdown') requestWakeLock();

      if(!panelEl.classList.contains('hidden')) return;
      if(uiHidden){ showUI(true); bumpUI(); return; }
      togglePause();
      bumpUI();
    }, { passive:true });

    for(const el of document.querySelectorAll('button, label.btn')){
      el.addEventListener('click', (ev)=>ev.stopPropagation());
      el.addEventListener('touchstart', (ev)=>ev.stopPropagation(), { passive:true });
    }

    showPanel(true);
    showUI(true);
  }

  function enableStart(on){ startBtnEl.disabled = !on; }
  function showPanel(show){ panelEl.classList.toggle('hidden', !show); }

  function togglePause(){ if(simState !== "setup") paused = !paused; }

  function beginCountdown(){
  unlockAudioOnce();
  requestWakeLock();

  // Hide panel + UI immediately
  showPanel(false);
  setUIHidden(true);

  paused = false;

  // Small cinematic delay so recording starts clean
  setTimeout(() => {
    simState = "countdown";
    countdownFrames = max(1, floor(CFG.countdownSec * 60));

    if (recEnabled) startRecording();
  }, 200);
}

  function showUI(withToast){ setUIHidden(false); if(withToast) toastPulse(); }
  function setUIHidden(hidden){ uiHidden=hidden; hudEl.classList.toggle('hidden', hidden); controlsEl.classList.toggle('hidden', hidden); }

  function toastPulse(){
    toastEl.classList.add('show');
    setTimeout(()=>toastEl.classList.remove('show'), 1100);
  }

  function armAutoHide(){
    if(hideTimer) clearTimeout(hideTimer);
    setUIHidden(false);
    hideTimer = setTimeout(()=>setUIHidden(true), 2200);
  }

  function bumpUI(){
    if(hideTimer) clearTimeout(hideTimer);
    setUIHidden(false);
    hideTimer = setTimeout(()=>setUIHidden(true), 1800);
  }

  function unlockAudioOnce(){
    if(audioUnlocked) return;
    userStartAudio();
    audioUnlocked = true;
    resumeAudioNow();
    if(sfxTension){
      sfxTension.setLoop(true);
      sfxTension.setVolume(0);
      sfxTension.play();
    }
    updatePanelStatusThrottled(true);
  }

  function playOne(snd, vol){
    if(!audioUnlocked || !snd) return;
    snd.setVolume(SFX.master * vol);
    snd.play();
  }
  function playRandPop(){
    if(!audioUnlocked || !sfxPop.length) return;
    const snd = random(sfxPop);
    if(!snd) return;
    snd.setVolume(SFX.master * SFX.pop);
    snd.play();
  }

  function resumeAudioNow(){
    if(!audioUnlocked) return;
    const ctx = getAudioContext?.();
    if(ctx && ctx.state === 'suspended') ctx.resume();
    if(sfxTension){
      try{
        if(!sfxTension.isPlaying()){ sfxTension.setLoop(true); sfxTension.play(); }
        sfxTension.setVolume(SFX.master * SFX.tensionMax * tensionVol);
      }catch(_){}
    }
  }

  function onReturnToApp(){
    paused=false;
    resumeAudioNow();
    if(simState === 'running' || simState === 'countdown') requestWakeLock();
    const ctx = getAudioContext?.();
    if(audioUnlocked && ctx && ctx.state === 'suspended'){ showUI(true); bumpUI(); }
  }

  async function requestWakeLock(){
    try{
      if(!('wakeLock' in navigator)) return;
      if(wakeLock) return;
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', ()=>{ wakeLock=null; });
    }catch(_){}
  }
  function releaseWakeLock(){
    try{ wakeLock?.release?.(); }catch(_){}
    wakeLock=null;
  }


function syncFinalGlowToCanvas(){
  if (!finalGlowEl) return;
  const cnv = document.querySelector('canvas');
  if (!cnv) return;
  const r = cnv.getBoundingClientRect();
  // Match the visible canvas area (so glow is captured in recording / not full-screen on desktop)
  finalGlowEl.style.left = r.left + 'px';
  finalGlowEl.style.top = r.top + 'px';
  finalGlowEl.style.width = r.width + 'px';
  finalGlowEl.style.height = r.height + 'px';
}

  // Finale border glow (pulses when final 5) + bounds matched to canvas
  let lastGlowBoundsMs = 0;
  function updateCanvasGlowBounds(force=false){
    if(!finalGlowEl) return;
    const now = performance.now();
    if(!force && (now - lastGlowBoundsMs) < 800) return;
    lastGlowBoundsMs = now;

    const cnv = document.querySelector('canvas');
    if(!cnv) return;
    const r = cnv.getBoundingClientRect();
    finalGlowEl.style.left = r.left + "px";
    finalGlowEl.style.top = r.top + "px";
    finalGlowEl.style.width = r.width + "px";
    finalGlowEl.style.height = r.height + "px";
  }

  function updateFinaleGlow(){
    if(!finalGlowEl) return;

    const isFinale = (simState === "running" && players.length <= 5);
    finalGlowEl.classList.toggle('on', isFinale);

    // keep bounds correct on desktop where canvas isn't full-screen
    updateCanvasGlowBounds(false);

    if(!isFinale) return;

    const t = frameCount * 0.06;
    const pulse = (sin(t)*0.5+0.5);
    const a1 = 0.18 + pulse*0.32;
    const a2 = 0.22 + pulse*0.55;
    const a3 = 0.16 + pulse*0.55;

    finalGlowEl.style.boxShadow =
      `0 0 0 3px rgba(180, 70, 255, ${a1}) inset,
       0 0 0 10px rgba(180, 70, 255, ${a2}) inset,
       0 0 0 18px rgba(255, 0, 200, ${a3}) inset`;
  }

  function resetSim(keepSetupState){
    players=[]; projectiles=[]; particles=[]; frameShake=0;
    paused=false; winnerPlayed=false;

    zorb.y = height * CFG.robotY;
    zorb.aimX = width * 0.5;
    zorb.aimY = height * 0.5;
    zorb.charge = 0;
    zorb.recoil = 0;
    zorb.fireCooldown = 0;

    simState = keepSetupState ? "setup" : simState;
    countdownFrames = 0;

    const count = max(2, CFG.playerCount);
    const ids = Array.from({length:count}, (_,i)=>i+1);

    const topBound = height*0.30;
    const minY = height*0.32;
    const maxY = height - 22;
    const marginX = 18;

    for(let i=0;i<count;i++){
      const size = getDynamicBubbleSize(count);
      const r = random(size.min, size.max);

      let x = width*0.5, y=(topBound+height)*0.5;
      let ok=false;

      for(let attempt=0; attempt<240; attempt++){
        x = random(r+marginX, width-r-marginX);
        y = random(minY+r, maxY-r);
        ok=true;
        for(const other of players){
          const d = dist(x,y, other.x, other.y);
          if(d < r + other.r + 10){ ok=false; break; }
        }
        if(ok) break;
      }

      const handle = rosterHandles[i] || ("#" + ids[i]);
      players.push(new Bubble(ids[i], handle, x, y, r));
    }

    updatePanelStatusThrottled(true);
    updateHudThrottled(true);
  }

  function getRobotX(){
    const sway = sin(frameCount*CFG.robotSwaySpeedX) * (width*CFG.robotSwayFracX);
    const x = width*0.5 + sway;
    const estHalf = (zorbLoaded && zorbImg) ? (zorbImg.width*CFG.robotScale*0.52) : 120;
    return constrain(x, estHalf+8, width-estHalf-8);
  }

  function draw(){
    if(!paused) step();
    render();
    updateFinaleGlow();
    updateHudThrottled(false);
  }

  function step(){
    zorb.recoil *= 0.86;
    for(const s of stars) s.tw += s.sp;

    for(const b of players) b.update();
    for(let i=0;i<players.length;i++){
      for(let j=i+1;j<players.length;j++) players[i].separate(players[j]);
    }

    for(let i=projectiles.length-1;i>=0;i--){
      projectiles[i].update();
      if(projectiles[i].dead) projectiles.splice(i,1);
    }
    for(let i=particles.length-1;i>=0;i--){
      particles[i].update();
      if(particles[i].dead) particles.splice(i,1);
    }

    tensionTarget = (players.length<=5 && simState==="running") ? 1 : 0;
    tensionVol = lerp(tensionVol, tensionTarget, 0.02);
    if(audioUnlocked && sfxTension) sfxTension.setVolume(SFX.master*SFX.tensionMax*tensionVol);

    if(simState==="countdown"){
      countdownFrames -= 1;
      if(countdownFrames<=0){ simState="running"; countdownFrames=0; }
      return;
    }
    if(simState!=="running") return;

    zorb.fireCooldown -= deltaTime/1000;
    if(zorb.fireCooldown<=0 && players.length>1){
      let rate = CFG.fireRate;
      if(players.length<=5) rate = CFG.fireRateFinal;
      if(players.length<=2) rate = CFG.fireRateFinal2;

      if(players.length<=5 && frameCount % CFG.slowMoFrames < 10){
        // slow-mo beat
      }else{
        if(zorb.charge<=0){
          zorb.charge = CFG.chargeTime;

          const t = pickTarget();
          zorb.aimX = t.x + random(-CFG.aimJitter, CFG.aimJitter);
          zorb.aimY = t.y + random(-CFG.aimJitter, CFG.aimJitter);

          if(random() < CFG.nearMissChance*CFG.chaos){
            zorb.aimX += random([-1,1])*random(40,80);
            zorb.aimY += random(20,60);
            playOne(sfxWoosh, SFX.woosh);
          }
        }

        zorb.charge -= 1;
        if(zorb.charge<=0){
          fireShot();
          zorb.fireCooldown = 1/(rate*CFG.chaos);
        }
      }
    }

    if(players.length===1){
      simState="finished";
      if(!winnerPlayed){
        playOne(sfxWinner, SFX.winner);
        winnerPlayed=true;
        (async () => {

  try {
    await reportWinnerToBackend(players[0]);
  } catch (e) {
    console.error("reportWinnerToBackend failed", e);
  } finally {
    releaseWakeLock();
  }
})();
      }
    }
  }

  function pickTarget(){
    const avoidWinner = BACKEND_WINNER && players.length>2;
    const pool = avoidWinner ? players.filter(b=>b.handle !== BACKEND_WINNER) : players;
    if(pool.length===0) return random(players);
    if(players.length>12) return random(pool);

    let best = pool[0], bestScore=-1e9;
    for(const b of pool){
      const centerBias = -dist(b.x,b.y, width*0.5, height*0.62);
      const motion = b.v.mag()*120;
      const score = centerBias + motion + random(-80,80);
      if(score>bestScore){ bestScore=score; best=b; }
    }
    return best;
  }

  function cannonOrigins(){
    const robotX = getRobotX();
    const hoverY = sin(frameCount*CFG.robotHoverSpeedY)*CFG.robotHoverAmpY;

    const sx = CFG.robotScale;
    const imgW = (zorbLoaded && zorbImg) ? zorbImg.width*sx : 320*sx;
    const imgH = (zorbLoaded && zorbImg) ? zorbImg.height*sx : 320*sx;

    const left = robotX - imgW*0.5;
    const top  = (zorb.y + hoverY) - imgH*0.5;

    const y = top + imgH*CFG.cannonYFrac;
    return CFG.cannonXFrac.map(fr => ({ x: left + imgW*fr, y }));
  }

  function fireShot(){
    const origin = random(cannonOrigins());
    const dir = createVector(zorb.aimX-origin.x, zorb.aimY-origin.y).normalize();
    const speed = CFG.projectileSpeed*(0.85+0.3*CFG.chaos);
    const vel = dir.mult(speed);

    const piercing = random() < CFG.multiElimChance*CFG.chaos;
    const ricochet = random() < CFG.ricochetChance*CFG.chaos;

    projectiles.push(new Projectile(origin.x, origin.y, vel.x, vel.y, piercing, ricochet));

    playOne(sfxFire, SFX.fire);
    zorb.recoil = 1.0;

    // Subtle shake on shot (big shake stays on POP)
    frameShake = max(frameShake, CFG.screenShakeShot*(players.length<=5?1.0:0.8));
  }

  function render(){
    let sx=0, sy=0;
    if(frameShake>0 && !paused){
      sx = random(-frameShake, frameShake);
      sy = random(-frameShake, frameShake);
      frameShake *= 0.86;
    }

    push();
    translate(sx, sy);

    background(CFG.bgColor);
    drawStars();
    if(CFG.vignette) drawVignette();

    for(const p of projectiles) p.draw();
    for(const b of players) b.draw();
    drawZorb();
    for(const pt of particles) pt.draw();

    if(simState==="countdown") drawCountdown();
    if(simState==="finished" && players.length===1){
      drawFinaleAura();
      drawWinner(players[0]);
    }

    pop();
  }

  function drawStars(){
    noStroke();
    for(const s of stars){
      const tw = (sin(s.tw)*0.5+0.5);
      fill(180,200,255, 80 + tw*175);
      circle(s.x, s.y, s.r);
    }
  }

  function drawVignette(){
    noFill();
    for(let i=0;i<14;i++){
      stroke(0,0,0,14);
      rect(-i,-i, width+2*i, height+2*i, 22);
    }
  }

  function drawFinaleAura(){
    const ctx = drawingContext;
    ctx.save();

    const cx = width*0.5;
    const cy = height*0.5;
    const radius = max(width,height)*0.85;

    const gradient = ctx.createRadialGradient(cx,cy, radius*0.2, cx,cy, radius);
    gradient.addColorStop(0, "rgba(160, 80, 255, 0.25)");
    gradient.addColorStop(0.4, "rgba(130, 50, 255, 0.18)");
    gradient.addColorStop(1, "rgba(80, 0, 180, 0.45)");

    ctx.fillStyle = gradient;
    ctx.fillRect(0,0,width,height);
    ctx.restore();
  }

  function drawZorb(){
    const robotX = getRobotX();
    const hoverY = sin(frameCount*CFG.robotHoverSpeedY)*CFG.robotHoverAmpY;
    const scaleAmt = CFG.robotScale*(1 + zorb.recoil*0.01);

    if(zorbLoaded && zorbImg){
      push();
      imageMode(CENTER);
      drawingContext.save();
      drawingContext.filter = "blur(22px)";
      tint(255,0,200, zorb.charge>0 ? 180 : 110);
      image(zorbImg, robotX, zorb.y+hoverY, zorbImg.width*scaleAmt*1.15, zorbImg.height*scaleAmt*1.15);
      drawingContext.restore();
      pop();
    }

    imageMode(CENTER);
    if(zorbLoaded && zorbImg && zorbImg.width){
      if(zorb.charge>0){
        push(); tint(255,255,255,210);
        image(zorbImg, robotX, zorb.y+hoverY, zorbImg.width*scaleAmt*1.01, zorbImg.height*scaleAmt*1.01);
        pop();
      }
      image(zorbImg, robotX, zorb.y+hoverY, zorbImg.width*scaleAmt, zorbImg.height*scaleAmt);
    }else{
      push();
      translate(robotX, zorb.y+hoverY);
      noStroke();
      fill(80,240,220,210); ellipse(0,0,210,80);
      fill(255,0,200,55); ellipse(0,0,260,110);
      pop();
    }

    for(const o of cannonOrigins()){
      const glow = zorb.charge>0 ? map(zorb.charge, CFG.chargeTime, 0, 20, 130) : 18;
      noStroke(); fill(255,220,0,glow); circle(o.x,o.y,14);
    }
  }

  function drawCountdown(){
    const secLeft = ceil(countdownFrames/60);
    noStroke(); fill(0,0,0,110); rect(0,0,width,height);
    fill(255,255,255,240);
    textAlign(CENTER,CENTER);
    textSize(54); text(secLeft, width*0.5, height*0.50);
    textSize(16); fill(255,255,255,220);
    text("Zorbi begins…", width*0.5, height*0.56);
  }

  
  function drawWinner(b){
    noStroke();
    fill(0,0,0,120);
    rect(0,0,width,height);

    const cx = width*0.5, cy = height*0.52;
    const R  = min(width, height) * 0.23;
    const pulse = sin(frameCount*0.06)*0.5+0.5;

    // Purple outer glow burst
    noStroke();
    fill(160, 80, 255, 40 + pulse*50);
    circle(cx, cy, R*2.8 + pulse*30);

    // Main ring
    stroke(190,245,255,140);
    strokeWeight(5);
    fill(255,255,255,14);
    circle(cx, cy, R*2);

    // Bubble shine
    noStroke();
    fill(255,255,255,58);
    ellipse(cx - R*0.28, cy - R*0.32, R*1.05, R*0.68);

    // Bubble content
    {
      const label = (b.handle ? "@" + b.handle : String(b.id));
      let ts = R * 0.52;
      if (label.length > 8) ts = R * 0.38;
      if (label.length > 12) ts = R * 0.32;

      textAlign(CENTER, CENTER);
      textSize(ts);

      // crisp white with soft purple glow (no chunky black stroke)
      drawingContext.save();
      drawingContext.shadowBlur = 22;
      drawingContext.shadowColor = "rgba(180, 90, 255, 0.85)";
      fill(255,255,255,250);
      text(label, cx, cy + 6);
      drawingContext.restore();
    }

    // ===== WINNER HEADER (banner + glow) =====
    const by = height * 0.16;
    const bannerW = min(width * 0.88, 520);
    const bannerH = 62;

    rectMode(CENTER);
    noStroke();

    // layered glow fills
    fill(160, 80, 255, 38 + pulse*42);
    rect(cx, by, bannerW + 18, bannerH + 10, 18);

    fill(255, 0, 200, 60 + pulse*65);
    rect(cx, by, bannerW, bannerH, 18);

    // text with glow
    textAlign(CENTER, CENTER);
    textSize(40);

    drawingContext.save();
    drawingContext.shadowBlur = 26;
    drawingContext.shadowColor = "rgba(255, 0, 200, 0.65)";
    fill(255,255,255,250);
    text("WINNER!", cx, by);
    drawingContext.restore();

    // ===== HANDLE DISPLAY =====
    const hLabel = (b.handle ? "@" + b.handle : ("#" + b.id));
    textSize(24);

    drawingContext.save();
    drawingContext.shadowBlur = 18;
    drawingContext.shadowColor = "rgba(120, 220, 255, 0.80)";
    fill(170, 240, 255, 250);
    text(hLabel, cx, height*0.24);
    drawingContext.restore();

    // ===== FOLLOW CTA =====
    textSize(16);

    drawingContext.save();
    drawingContext.shadowBlur = 14;
    drawingContext.shadowColor = "rgba(180, 90, 255, 0.55)";
    fill(230, 210, 255, 250);
    text('Follow @Zorbi.ai + comment "IN" to enter tomorrow', cx, height*0.29);
    drawingContext.restore();

    rectMode(CORNER);
  }


  function drawBubbleLabel(label, x, y, r){
    label = String(label||"");
    let shown = label;
    if(shown.length>14) shown = shown.slice(0,13)+"…";

    let ts = r*0.55;
    if(shown.length>6) ts = r*0.42;
    if(shown.length>10) ts = r*0.34;

    textAlign(CENTER,CENTER);
    stroke(0,0,0,180); strokeWeight(6);
    fill(255,255,255,245); textSize(ts);
    text(shown, x, y);

    stroke(255,255,255,90); strokeWeight(2);
    fill(255,255,255,245);
    text(shown, x, y);
  }

  class Bubble{
    constructor(id, handle, x, y, r){
      this.id=id;
      this.handle=handle||null;
      this.x=x; this.y=y; this.r=r;

      this.v=createVector(random(-1,1), random(-1,1)).mult(random(0.6,1.6));
      this.wob=random(TAU);
      this.wobSp=random(0.02,0.05);

      this.spin=random([-1,1])*random(0.8,1.35);
      this.swirl=random(0.6,1.4);
    }

    update(){
      const f = p5.Vector.random2D().mult(CFG.wanderForce*CFG.chaos);
      this.v.add(f);

      const cx=width*0.5, cy=height*0.60;
      const toC=createVector(cx-this.x, cy-this.y);

      const tangent=createVector(-toC.y, toC.x).normalize()
        .mult(CFG.swirlStrength*this.spin*this.swirl*CFG.chaos);
      this.v.add(tangent);

      if(random() < CFG.swirlJukeChance*CFG.chaos){
        const j=p5.Vector.random2D().mult(CFG.swirlJukeForce*random(0.7,1.2));
        this.v.add(j);
      }

      const maxV = CFG.maxSpeed*(0.85+0.35*CFG.chaos);
      if(this.v.mag()>maxV) this.v.setMag(maxV);

      this.x += this.v.x;
      this.y += this.v.y;

      const topBound = height*0.28;
      if(this.x < this.r){ this.x=this.r; this.v.x*=-1; }
      if(this.x > width-this.r){ this.x=width-this.r; this.v.x*=-1; }
      if(this.y < topBound+this.r){ this.y=topBound+this.r; this.v.y*=-1; }
      if(this.y > height-this.r){ this.y=height-this.r; this.v.y*=-1; }

      this.v.mult(CFG.bounceDamping);
      this.wob += this.wobSp;
    }

    separate(other){
      const dx=other.x-this.x, dy=other.y-this.y;
      const d=Math.sqrt(dx*dx+dy*dy);
      const minD=this.r+other.r+8;
      if(d>0 && d<minD){
        const overlap=(minD-d)/minD;
        const push=overlap*CFG.separationStrength*(1+0.35*CFG.chaos);
        const nx=dx/d, ny=dy/d;

        this.x -= nx*push*40; this.y -= ny*push*40;
        other.x += nx*push*40; other.y += ny*push*40;

        this.v.x -= nx*push*1.2; this.v.y -= ny*push*1.2;
        other.v.x += nx*push*1.2; other.v.y += ny*push*1.2;
      }
    }

    draw(){
      push();
      translate(this.x,this.y);
      const wobble = 1 + sin(this.wob)*0.03;

      noStroke();
      fill(120,220,255,24);
      circle(0,0, this.r*2 + CFG.bubbleGlow);

      stroke(190,245,255,110);
      strokeWeight(3);
      fill(255,255,255,14);
      ellipse(0,0, this.r*2*wobble, this.r*2*(2-wobble));

      const label = this.handle ? ("@"+this.handle) : String(this.id);
      drawBubbleLabel(label, 0, 6, this.r);

      noStroke();
      fill(255,255,255,55);
      ellipse(-this.r*0.28, -this.r*0.32, this.r*0.85, this.r*0.55);

      pop();
    }
  }

  class Projectile{
    constructor(x,y,vx,vy,piercing=false,ricochet=false){
      this.x=x; this.y=y;
      this.v=createVector(vx,vy);
      this.r=CFG.projectileRadius;
      this.dead=false;
      this.piercing=piercing;
      this.ricochet=ricochet;
      this.hasRicocheted=false;
    }

    update(){
      this.x += this.v.x;
      this.y += this.v.y;

      if(this.y > height+120 || this.x < -120 || this.x > width+120){
        this.dead=true; return;
      }

      for(let i=players.length-1;i>=0;i--){
        const b=players[i];
        if(dist(this.x,this.y,b.x,b.y) < b.r + this.r){
          if(BACKEND_WINNER && b.handle === BACKEND_WINNER && players.length>1){
            this.dead=true; break;
          }

          popBubble(b);
          players.splice(i,1);

          if(!this.piercing){
            this.dead=true;
          }else{
            this.r *= 0.92;
            this.v.mult(0.92);
            if(this.r < 6) this.dead=true;
          }

          if(this.ricochet && !this.hasRicocheted && !this.dead){
            this.hasRicocheted=true;
            const nv=p5.Vector.random2D().mult(CFG.projectileSpeed*0.85);
            nv.y = abs(nv.y) + 6;
            this.v = nv;
          }
          break;
        }
      }
    }

    draw(){
      noStroke();
      fill(255,120,0,55); circle(this.x,this.y,this.r*4.4);
      fill(255,240,120,220); circle(this.x,this.y,this.r*1.8);
      stroke(255,255,255,70); strokeWeight(3);
      line(this.x,this.y, this.x - this.v.x*2.0, this.y - this.v.y*2.0);
    }
  }

  class Particle{
    constructor(x,y,vx,vy,life,kind='spark'){
      this.x=x; this.y=y;
      this.v=createVector(vx,vy);
      this.life=life; this.maxLife=life;
      this.kind=kind;
      this.dead=false;
      this.r=(kind==='pop') ? random(3,7) : random(2,4);
    }
    update(){
      this.x += this.v.x;
      this.y += this.v.y;
      this.v.mult(0.93);
      this.life -= 1;
      if(this.life<=0) this.dead=true;
    }
    draw(){
      const a = map(this.life, 0, this.maxLife, 0, 255);
      noStroke();
      if(this.kind==='pop') fill(255,255,255,a);
      else fill(255,80,240,a);
      circle(this.x,this.y,this.r);
    }
  }

  function cueReloadAfterPop(){
    // Play *once* shortly after the last pop in a multi-elimination burst.
    if (reloadTimer) clearTimeout(reloadTimer);
    reloadTimer = setTimeout(() => {
      if (simState !== "running") return;
      if (players.length <= 1) return;
      try { sfxReload?.stop?.(); } catch(_) {}
      playOne(sfxReload, SFX.reload);
      reloadTimer = null;
    }, 420);
  }

  function popBubble(b){
    playRandPop();
    playOne(sfxBass, SFX.bass);

    // Big shake on POP (not on every shot)
    frameShake = max(frameShake, CFG.screenShakePop*(players.length<=5?1.2:1.0));

    // Better reload timing: shortly after pop
    cueReloadAfterPop();

    for(let i=0;i<CFG.popParticles;i++){
      const v=p5.Vector.random2D().mult(random(2.5,8.5));
      v.y += 1.2;
      particles.push(new Particle(b.x,b.y,v.x,v.y,CFG.sparkLife,'spark'));
    }
    for(let i=0;i<10;i++){
      const v=p5.Vector.random2D().mult(random(1.2,6.2));
      particles.push(new Particle(b.x,b.y,v.x,v.y,CFG.popLife,'pop'));
    }
  }

  async function reportWinnerToBackend(b) {
  const payload = { winner: b.handle || ("#" + b.id), winnerSlot: b.id };

  for (let attempt = 1; attempt <= 3; attempt++) {
    try {
      const res = await fetch(WINNER_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      const text = await res.text(); // read body even if not json
      if (!res.ok) throw new Error(`HTTP ${res.status} • ${text}`);

      // visible success
      try {
        toastEl.textContent = "Winner saved ✅";
        toastPulse();
      } catch (_) {}

      return true;
    } catch (e) {
      // visible failure
      try {
        toastEl.textContent = `Winner save failed (try ${attempt})`;
        toastPulse();
      } catch (_) {}

      console.warn("Winner POST failed:", e);

      // small backoff
      await new Promise(r => setTimeout(r, 700 * attempt));
    }
  }

  return false;
}

  function updatePanelStatus(){
    panelRosterEl.textContent = `Roster: ${CFG.playerCount} entrants`;

    panelZorbEl.textContent = zorbLoaded ? "Zorb: OK" : "Zorb: missing";
    panelZorbEl.classList.toggle('ok', zorbLoaded);
    panelZorbEl.classList.toggle('warn', !zorbLoaded);

    panelAudioEl.textContent = audioUnlocked ? "Audio: unlocked" : "Audio: locked";
    panelAudioEl.classList.toggle('ok', audioUnlocked);
    panelAudioEl.classList.toggle('warn', !audioUnlocked);

    panelBackendEl.textContent = BACKEND_OK ? `Backend: OK (${CFG.playerCount})` : "Backend: offline";
    panelBackendEl.classList.toggle('ok', BACKEND_OK);
    panelBackendEl.classList.toggle('bad', !BACKEND_OK);

    enableStart(true);
  }

  function updateHud(){
    const z = zorbLoaded ? "ok" : "MISSING Zorb2.PNG";
    const a = audioUnlocked ? "unlocked" : "locked";
    const state = (simState==="setup") ? "SETUP" : (simState==="countdown") ? "COUNTDOWN" : (simState==="running") ? "RUNNING" : "FINISH";
    const cd = (simState==="countdown") ? ` • starts in ${ceil(countdownFrames/60)}s` : "";
    const rd = ROUND_META?.round_date ? ` • ${ROUND_META.round_date}` : "";
    const mode = ROUND_META?.mode ? ` • ${ROUND_META.mode}` : "";
    const backend = BACKEND_OK ? " • backend OK" : " • backend offline";

    hudStatusEl.textContent =
      `State: ${state}${rd}${mode}${backend} • Zorb: ${z} • Audio: ${a}` +
      ` • Players: ${CFG.playerCount} • Remaining: ${players.length} • Chaos: ${CFG.chaos.toFixed(2)}${cd}` +
      (paused ? " • PAUSED" : "");
  }

  function updatePanelStatusThrottled(force=false){
    const now = performance.now();
    if(force || now - lastPanelUpdateMs > 800){
      lastPanelUpdateMs = now;
      updatePanelStatus();
    }
  }
  function updateHudThrottled(force=false){
    const now = performance.now();
    if(force || now - lastHudUpdateMs > 250){
      lastHudUpdateMs = now;
      updateHud();
      updatePanelStatusThrottled(false);
    }
  }

  </script>
</body>
</html>
