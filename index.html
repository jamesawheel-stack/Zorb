<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <link rel="icon" type="image/png" href="zorb.png">
  <link rel="shortcut icon" type="image/png" href="zorb.png">
  <title>Zorbi – Mobile Full</title>
  <style>
    :root{
      --bg:#0B0F1F;
      --panel:rgba(0,0,0,0.35);
      --panel2:rgba(0,0,0,0.58);
      --stroke:rgba(255,255,255,0.14);
      --text:rgba(255,255,255,0.92);
      --btn:rgba(255,255,255,0.11);
      --btnHover:rgba(255,255,255,0.18);
      --good:rgba(120,255,170,0.92);
      --warn:rgba(255,210,120,0.92);
      --bad:rgba(255,120,120,0.92);
    }
    html,body{margin:0;padding:0;background:var(--bg);overflow:hidden;height:100%}
    canvas{display:block;margin:0 auto;touch-action:none}

    #hud{
      position:fixed;left:12px;top:12px;z-index:10;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);font-size:12px;line-height:1.25;
      background:var(--panel);border:1px solid var(--stroke);
      padding:10px 12px;border-radius:12px;backdrop-filter:blur(10px);
      max-width:420px;
    }
    #hud b{font-size:13px}
    #hud .tiny{opacity:.78;font-size:11px;margin-top:6px}
    #hud .row{display:flex;gap:8px;align-items:center;margin-top:8px}
    #hud .btnTiny{
      font:inherit;font-weight:800;letter-spacing:.2px;
      color:rgba(255,255,255,0.92);
      background:rgba(0,0,0,0.55);
      border:1px solid rgba(255,255,255,0.18);
      border-radius:10px;
      padding:6px 10px;cursor:pointer;
    }
    #hud .btnTiny:active{transform:translateY(1px);background:var(--btnHover)}

    #panel{
      position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
      z-index:30;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--panel2);border:1px solid rgba(255,255,255,0.18);
      padding:18px 18px 14px;border-radius:16px;color:var(--text);
      width:min(92vw,460px);text-align:center;backdrop-filter:blur(12px);
    }
    #panel h1{font-size:18px;margin:0 0 10px}
    #panel p{margin:8px 0;font-size:12px;opacity:.92;line-height:1.35}
    #panel .row{display:flex;gap:10px;justify-content:center;align-items:center;flex-wrap:wrap;margin-top:10px}
    #panel .note{font-size:11px;opacity:.75;margin-top:10px}
    #panel .status{margin-top:10px;font-size:12px;opacity:.95}
    #panel .pill{
      background:rgba(0,0,0,0.55);
      border:1px solid rgba(255,255,255,0.14);
      padding:8px 12px;border-radius:999px;
      font-weight:800;color:rgba(255,255,255,0.92);
      text-shadow:0 2px 10px rgba(0,0,0,0.6);
    }
    #panel .ok{color:var(--good)} #panel .warn{color:var(--warn)} #panel .bad{color:var(--bad)}

    #controls{
      position:absolute;left:12px;right:12px;bottom:12px;
      padding:12px; border-radius:18px;
      background:rgba(0,0,0,0.42);
      border:1px solid rgba(255,255,255,0.10);
      box-shadow:0 0 0 1px rgba(255,0,255,0.10), 0 18px 40px rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
    }
    .btn{
      background:rgba(0,0,0,0.55);
      color:rgba(255,255,255,0.92);
      border:1px solid rgba(255,255,255,0.18);
      border-radius:14px;
      padding:12px 16px;
      font-weight:800;
      letter-spacing:.2px;
      box-shadow:0 0 0 1px rgba(255,0,255,0.15), 0 8px 24px rgba(0,0,0,0.35);
      text-shadow:0 2px 10px rgba(0,0,0,0.6);
    }
    .btn:active{transform:translateY(1px);background:var(--btnHover)}
    .btn.wide{min-width:110px}
    .btn.primary{border-color:rgba(120,255,170,0.35);background:rgba(120,255,170,0.12)}
    select.btn{
      background:var(--btn);
      color:var(--text);
      border:1px solid rgba(255,255,255,0.18);
      -webkit-appearance:none;appearance:none;
    }
    select.btn option{background:var(--bg);color:var(--text)}
    .hidden{display:none!important}

    #toast{
      position:fixed;left:50%;top:14px;transform:translateX(-50%);
      z-index:40;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      font-size:12px;color:var(--text);
      background:rgba(0,0,0,0.55);border:1px solid rgba(255,255,255,0.14);
      padding:8px 10px;border-radius:999px;backdrop-filter:blur(10px);
      opacity:0;transition:opacity 220ms ease;pointer-events:none;
    }
    #toast.show{opacity:1}
  </style>
</head>

<body>
  <div id="toast">UI shown</div>

  <div id="hud">
    <b>Zorbi – Today’s Round</b>
    <div id="hudStatus">Loading…</div>
    <div class="row">
      <button class="btnTiny" id="btnMute" type="button">MUTE</button>
    </div>
    <div class="tiny">Tap background: pause/resume • Tap anywhere when UI hidden: show UI</div>
  </div>

  <div id="panel">
    <h1 id="panelTitle">Load today’s roster</h1>
    <p>Today’s roster supports up to <b id="maxCountLabel">?</b> entrants. Press <b>Start</b> to begin.</p>
    <div class="row">
      <button class="btn wide primary" id="startBtn" type="button">Start Battle</button>
      <button class="btn wide" id="clearBtn" type="button">Reset</button>
    </div>
    <div class="row">
      <button class="btn wide" id="modeBtn" type="button">MODE: LIVE</button>
      <select class="btn wide" id="offlineCountSel">
        <option value="120">OFFLINE: 120</option>
        <option value="250" selected>OFFLINE: 250</option>
        <option value="500">OFFLINE: 500</option>
        <option value="1000">OFFLINE: 1000</option>
        <option value="2500">OFFLINE: 2500</option>
        <option value="5000">OFFLINE: 5000</option>
      </select>
    </div>
    <div class="status">
      <span class="pill" id="panelRoster">Roster: …</span>
      <span class="pill" id="panelZorb">Zorb: …</span>
      <span class="pill" id="panelAudio">Audio: …</span>
      <span class="pill" id="panelBackend">Backend: …</span>
      <span class="pill" id="panelSprites">Sprites: …</span>
    </div>
    <div class="note">After Start: UI hides immediately (and stays hidden all game unless you tap).</div>
  </div>

  <div id="controls">
    <button class="btn wide" id="btnShowPanel" type="button">Roster</button>
    <button class="btn" id="btnPause" type="button">Pause</button>
    <button class="btn" id="btnRestart" type="button">Restart</button>
    <button class="btn wide" id="btnHide" type="button">Hide UI</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/addons/p5.sound.min.js"></script>

  <script>
  const BACKEND_BASE =
    (location.hostname === "localhost" || location.hostname === "127.0.0.1")
      ? "http://localhost:10000"
      : "https://zorb.onrender.com";

  const ROUND_URL  = BACKEND_BASE + "/top50.json";
  const WINNER_URL = BACKEND_BASE + "/round/today/winner";

  let USE_BACKEND = true;
  let OFFLINE_COUNT = 250;

  let ROUND_META = { round_date:null, mode:null, claimed_total:null, finale_count:null, status:null, seed:null, round_number:2 };
  let BACKEND_WINNER = null;
  let BACKEND_OK = false;

  const DESIGN = { w:1080, h:1920 };
  function dx(x){ return x * (width / DESIGN.w); }
  function dy(y){ return y * (height / DESIGN.h); }
  function dw(w){ return w * (width / DESIGN.w); }
  function dh(h){ return h * (height / DESIGN.h); }

  const UI_FRAME = { w:1024, h:1536, innerL:160, innerR:863, innerT:218, innerB:1389 };
  const FRAME_PAD_PX = { l:0, r:0, t:0, b:0 };

  const CFG = {
    aspectW:9, aspectH:16,
    baseHeight:1920,
    bgColor:'#0B0F1F',
    vignette:true,

    bubbleCeilingDesignY: 640,
    bubbleAreaInsetDesign: { left: 18, right: 18, top: 6, bottom: 92 },

    wanderForce:0.18,
    maxSpeed:2.45,
    bounceDamping:0.986,
    separationStrength:0.30,
    swirlStrength:0.055,
    swirlJukeChance:0.010,
    swirlJukeForce:1.35,

    robotScale:0.14,
    robotY:0.20,
    robotYOffsetDesign: 55,
    robotHoverAmpY:9,
    robotHoverSpeedY:0.028,
    robotSwayFracX:0.08,
    robotSwaySpeedX:0.018,

    cannonXFrac:[0.34,0.50,0.66],
    cannonYFrac:0.65,

    aimJitter:16,
    projectileSpeed:16,
    projectileRadius:10,

    screenShakePop:3.2,
    screenShakeShot:0.9,
    shakeDecay:0.92,
    shakeCap:2.6,

    popParticles:12,
    popLife:20,
    sparkLife:12,

    namesFadeStartN: 55,
    namesFadeFullN:  20,
    glowSwapFinalN:  10,

    bubbleDrawScale: 0.96,

    bannerBoxWDesign: 270,
    bannerBoxHDesign: 85,
    bannerInsetXDesign: 148,
    bannerTopYDesign: 262,

    bubbleSpriteW: 720,
    bubbleSpriteH: 700,
    bubbleContentCenterYPx: 342,
    bubbleLabelExtraYOffset: 0,

    winnerNameCenterYDesign: 840,
    winnerNameMaxWDesign:    550,
    winnerNameCenterXDesign: 540,
  };

  // SCALE: fixed sim bubble count, recycle while remaining is huge
  const PERF = {
    maxSimBubbles: 160,
    physicsHz: 30,
    cellSize: 140,
    recycleModeThreshold: 160,
    repositionAttempts: 18,
    maxProjectiles: 60,          // safety cap
  };

  const BATTLE_TIME_CAP_SEC = 30;
  const DIRECT_POP_THRESHOLD = 90;
  let elimBudget = 0;

  // Audio throttles (burst-level, NOT per bubble)
  let lastBurstSfxMs = 0;
  const BURST_SFX_COOLDOWN_MS = 90;   // 1 sound per burst
  let lastWooshSfxMs=0;
  const WOOSH_SFX_COOLDOWN_MS = 120;

  // Token-budgets (prevents p5.sound scheduling churn on huge rounds)
  let popTokens = 0, shotTokens = 0;
  function popTokenRate(rem){
    if(rem >= 2500) return 2.6;
    if(rem >= 1200) return 3.8;
    if(rem >= 600)  return 5.0;
    if(rem >= 250)  return 7.0;
    return 10.0;
  }
  function shotTokenRate(rem){
    if(rem >= 2500) return 3.2;
    if(rem >= 1200) return 4.2;
    if(rem >= 600)  return 6.0;
    if(rem >= 250)  return 8.0;
    return 10.0;
  }
  function refillSfxTokens(dt, rem){
    popTokens  = Math.min(10, popTokens  + popTokenRate(rem)  * dt);
    shotTokens = Math.min(10, shotTokens + shotTokenRate(rem) * dt);
  }
  function takePopToken(){ if(popTokens >= 1){ popTokens -= 1; return true; } return false; }
  function takeShotToken(){ if(shotTokens >= 1){ shotTokens -= 1; return true; } return false; }

  let zorbImg, zorbLoaded=false;
  let uiFrameImg=null, winnerFrameImg=null, bgImg=null, bgGlowImg=null;
  let bubbleImg=null, glowImg=null;
  let spritesOk=false;

  let audioUnlocked=false;
  let musicMuted=false;

  // Pools
  const AUDIO_POOL_N = 4;
  let sfxPop=[], sfxWinner=null, sfxMusic=null, sfxTension=null;
  let sfxFirePool=[], sfxReloadPool=[], sfxBassPool=[], sfxWooshPool=[];
  let _fireIdx=0, _reloadIdx=0, _bassIdx=0, _wooshIdx=0;

  let tensionTarget=0, tensionVol=0, winnerPlayed=false;
  let musicStarted=false;
  let musicRestartTimer=null, musicStopTimer=null;

  const SFX={ master:0.90, pop:0.70, fire:0.70, reload:0.38, bass:0.82, woosh:0.55, tensionMax:0.55, winner:0.95 };
  const MUSIC = { bed:0.18, fadeInMs:900, duckLevel:0.05, duckMs:900 };

  let rosterHandles=[];
  let players=[], projectiles=[], particles=[];
  let paused=false;
  let frameShake=0;
  let simState="setup";
  let countdownFrames=0, countdownLabels=[], lastCountdownSec=-1;

  let ARENA_START_COUNT=0;
  let REMAINING_TOTAL=0;
  let NEXT_SPAWN_ID=1;

  let zorb={ y:0, aimX:0, aimY:0, recoil:0, fireCooldown:0, aimMeta:null };

  let winnerMomentFrames = 0;
  const WINNER_MOMENT_LEN = 54;

  let hudEl, hudStatusEl, panelEl, toastEl, controlsEl;
  let panelRosterEl, panelZorbEl, panelAudioEl, panelBackendEl, panelSpritesEl, startBtnEl;
  let uiHidden=false, hideTimer=null;
  let lastHudUpdateMs=0, lastPanelUpdateMs=0;
  let wakeLock=null;

  let accumMs = 0;
  const FIXED_DT_MS = 1000 / PERF.physicsHz;

  // Finale glow pulse
  let finalePulseT = 0;
  const MILESTONES = [2500, 1200, 600, 250, 120, 70, 35, 20, 10, 5];
  const hitMilestones = new Set();

  function totalRemaining(){ return Math.max(0, REMAINING_TOTAL || 0); }

  function frameBounds(){
    const L = width  * (UI_FRAME.innerL / UI_FRAME.w) + FRAME_PAD_PX.l;
    const R = width  * (UI_FRAME.innerR / UI_FRAME.w) - FRAME_PAD_PX.r;
    const T = height * (UI_FRAME.innerT / UI_FRAME.h) + FRAME_PAD_PX.t;
    const B = height * (UI_FRAME.innerB / UI_FRAME.h) - FRAME_PAD_PX.b;
    return {L,R,T,B, W:(R-L), H:(B-T)};
  }

  function bubbleBounds(){
    const A = frameBounds();
    let dynCeil = Math.max(A.T, dy(CFG.bubbleCeilingDesignY));

    if(zorbLoaded && zorbImg){
      const sx = CFG.robotScale;
      const imgH = zorbImg.height * sx;
      const hoverY = Math.sin(frameCount*CFG.robotHoverSpeedY)*CFG.robotHoverAmpY;
      const robotTop = (zorb.y + hoverY) - imgH*0.5;
      const robotBottom = robotTop + imgH;
      dynCeil = Math.max(dynCeil, robotBottom + dy(18));
    }

    const inset = CFG.bubbleAreaInsetDesign || {left:0,right:0,top:0,bottom:0};
    const L = A.L + dx(inset.left);
    const R = A.R - dx(inset.right);
    const T = dynCeil + dy(inset.top);
    const B = A.B - dy(inset.bottom);

    return { L, R, T, B, W:(R-L), H:(B-T) };
  }

  function buildCountdownLabels(startCount){
    if(startCount >= 25) return ["3","2","1","GO!"];
    if(startCount >= 10) return ["READY?","GO!"];
    return ["GO!"];
  }

  function drawSoftCeilingFade(){
    const B = bubbleBounds();
    const ctx = drawingContext;
    ctx.save();
    const fadeH = Math.floor(dy(110));
    const lift  = Math.floor(dy(55));
    const yTop  = Math.floor(B.T - lift);
    const yBot  = Math.floor(B.T + fadeH);
    const g = ctx.createLinearGradient(0, yTop, 0, yBot);
    g.addColorStop(0.00, "rgba(11,15,31,0.00)");
    g.addColorStop(0.25, "rgba(11,15,31,0.22)");
    g.addColorStop(0.55, "rgba(11,15,31,0.10)");
    g.addColorStop(1.00, "rgba(11,15,31,0.00)");
    ctx.fillStyle = g;
    ctx.fillRect(Math.floor(B.L), yTop, Math.ceil(B.W), (yBot - yTop));
    ctx.restore();
  }

  function getDynamicBubbleSize(n){
    if(n<=5)   return {min:34,max:46};
    if(n<=10)  return {min:36,max:52};
    if(n<=20)  return {min:38,max:56};
    if(n<=40)  return {min:42,max:62};
    if(n<=60)  return {min:40,max:58};
    if(n<=100) return {min:22,max:34};
    return {min:16,max:22};
  }

  function unlockAudioNow(){
    if(audioUnlocked) return;
    try{ userStartAudio(); }catch(_){}
    audioUnlocked = true;

    if(sfxTension){
      try{
        sfxTension.stop();
        sfxTension.setLoop(true);
        sfxTension.amp(0, 0);
        sfxTension.play();
      }catch(_){}
    }

    // Constant atmosphere: start music once, keep looping.
    if(!musicMuted) startMusicSoft();
    updatePanelStatusThrottled(true);
  }

  function startMusicSoft(){
    if(!sfxMusic || !audioUnlocked || musicMuted) return;
    if(musicStarted) return;
    musicStarted = true;
    try{
      sfxMusic.stop();
      sfxMusic.setLoop(true);
      sfxMusic.amp(0, 0);
      sfxMusic.play();
      sfxMusic.amp(MUSIC.bed, Math.max(0.2, MUSIC.fadeInMs/1000));
    }catch(e){ console.warn("music start failed", e); }
  }

  function duckMusic(){
    if(!sfxMusic || !audioUnlocked) return;
    try{
      sfxMusic.amp(MUSIC.duckLevel, 0.08);
      if(musicRestartTimer){ clearTimeout(musicRestartTimer); musicRestartTimer = null; }
      musicRestartTimer = setTimeout(()=>{
        try{ sfxMusic.amp(MUSIC.bed, 0.25); }catch(_){}
        musicRestartTimer = null;
      }, MUSIC.duckMs);
    }catch(_){}
  }

  function stopMusicSoft(){
    // kept for mute/reset only
    if(!sfxMusic) return;
    if(musicRestartTimer){ clearTimeout(musicRestartTimer); musicRestartTimer = null; }
    if(musicStopTimer){ clearTimeout(musicStopTimer); musicStopTimer = null; }
    try{
      sfxMusic.amp(0, 0.18);
      musicStopTimer = setTimeout(()=>{
        try{ sfxMusic.stop(); }catch(_){}
        musicStopTimer = null;
      }, 220);
    }catch(_){}
    musicStarted = false;
  }

  function setMusicMuted(on){
    musicMuted = !!on;
    const btn = document.getElementById("btnMute");
    if(btn) btn.textContent = musicMuted ? "UNMUTE" : "MUTE";
    if(!audioUnlocked) return;
    if(musicMuted) stopMusicSoft();
    else startMusicSoft();
  }

  function playOne(snd, vol){
    if(!audioUnlocked || !snd) return;
    try{
      if(snd.isPlaying && snd.isPlaying()) snd.stop();
      snd.amp(SFX.master * vol, 0);
      snd.play();
    }catch(_){}
  }

  function playFromPool(pool, idxRefName, vol){
    if(!audioUnlocked || !pool || !pool.length) return false;
    try{
      let idx = (idxRefName === "fire") ? _fireIdx
              : (idxRefName === "reload") ? _reloadIdx
              : (idxRefName === "bass") ? _bassIdx
              : _wooshIdx;

      const snd = pool[idx % pool.length];
      if(idxRefName === "fire") _fireIdx++;
      else if(idxRefName === "reload") _reloadIdx++;
      else if(idxRefName === "bass") _bassIdx++;
      else _wooshIdx++;

      if(!snd) return false;
      if(snd.isPlaying && snd.isPlaying()) return false;

      snd.amp(SFX.master * vol, 0);
      snd.play();
      return true;
    }catch(_){
      return false;
    }
  }

  function playWooshThrottled(){
    if(!audioUnlocked || !sfxWooshPool.length) return;
    const now = performance.now();
    if(now - lastWooshSfxMs < WOOSH_SFX_COOLDOWN_MS) return;
    if(!takeShotToken()) return;
    lastWooshSfxMs = now;
    playFromPool(sfxWooshPool, "woosh", SFX.woosh);
  }

  function ensureAudioAlive(){
    if(!audioUnlocked) return;
    const ctx = (typeof getAudioContext === "function") ? getAudioContext() : null;
    if(ctx && ctx.state === "suspended"){
      try{ ctx.resume(); }catch(_){}
    }
  }

  // Hard reset of all audio on sim reset so nothing keeps piling up.
  function stopAllAudio(){
    if(musicRestartTimer){ clearTimeout(musicRestartTimer); musicRestartTimer = null; }
    if(musicStopTimer){ clearTimeout(musicStopTimer); musicStopTimer = null; }
    tensionTarget = 0; tensionVol = 0;

    try{ sfxMusic?.stop(); }catch(_){}
    try{ sfxTension?.stop(); }catch(_){}
    try{ sfxWinner?.stop(); }catch(_){}

    const pools = [sfxFirePool, sfxReloadPool, sfxBassPool, sfxWooshPool];
    for(const pool of pools){
      if(Array.isArray(pool)){
        for(const s of pool){ try{ s?.stop(); }catch(_){ } }
      }
    }
    if(Array.isArray(sfxPop)){
      for(const s of sfxPop){ try{ s?.stop(); }catch(_){ } }
    }

    musicStarted = false;
    winnerPlayed = false;
  }

  function normalizeHandle(h){
    if(!h) return null;
    let s = String(h).trim();
    s = s.replace(/^@/,'').trim();
    if(!s) return null;
    return s;
  }
  function isDisallowedHandle(h){
    const s = normalizeHandle(h);
    if(!s) return true;
    if(s.toLowerCase() === "zorbi.ai") return true;
    return false;
  }

  async function loadTodayRound(){
    if(!USE_BACKEND){
      BACKEND_OK = false;
      BACKEND_WINNER = null;
      const finalCount = Math.max(2, Math.min(5000000, Number(OFFLINE_COUNT||250)));
      rosterHandles = Array.from({length: finalCount}, (_,i)=> ("player"+(i+1)));
      rosterHandles = rosterHandles.filter(h => !isDisallowedHandle(h));
      ROUND_META = { round_date: new Date().toISOString().slice(0,10), round_number:2, mode:"offline", finale_count:finalCount };
      document.getElementById("maxCountLabel").textContent = String(finalCount);
      document.getElementById("panelTitle").textContent = "Load roster (OFFLINE TEST)";
      updateHudThrottled(true); updatePanelStatusThrottled(true);
      return true;
    }

    try{
      const ctrl = new AbortController();
      const to = setTimeout(()=>ctrl.abort(), 6500);
      const res = await fetch(ROUND_URL, { cache:"no-store", signal: ctrl.signal });
      clearTimeout(to);
      if(!res.ok) throw new Error("HTTP "+res.status);
      const round = await res.json();

      BACKEND_OK = true;
      const fc = Number(round?.finale_count || (round?.players?.length || 0) || 0);
      const finalCount = Math.max(2, fc || 50);

      let rawHandles = Array.isArray(round?.players)
        ? round.players.map(p => (p.handle || ("#" + p.slot)))
        : [];

      rawHandles = rawHandles.map(normalizeHandle).filter(h => h && !isDisallowedHandle(h));
      rosterHandles = rawHandles;

      BACKEND_WINNER = normalizeHandle(round?.winner || null);
      if(BACKEND_WINNER && isDisallowedHandle(BACKEND_WINNER)) BACKEND_WINNER = null;

      ROUND_META = {
        round_date: round?.round_date || null,
        round_number: Number(round?.round_number || round?.round || 2) || 2,
        mode: round?.mode || "live",
        finale_count: round?.finale_count ?? finalCount,
      };

      document.getElementById("maxCountLabel").textContent = String(finalCount);
      document.getElementById("panelTitle").textContent = "Load today’s roster (LIVE)";
      updateHudThrottled(true); updatePanelStatusThrottled(true);
      return true;
    }catch(e){
      BACKEND_OK=false;
      document.getElementById("panelTitle").textContent = "Load today’s roster (offline mode)";
      updateHudThrottled(true); updatePanelStatusThrottled(true);
      console.warn("Round load failed:", e);
      return false;
    }
  }

  function preload(){
    zorbImg = loadImage('zorb.png', ()=>{ zorbLoaded=true; }, ()=>{ zorbLoaded=false; console.warn("zorb.png failed"); });

    bgImg = loadImage('background.png', ()=>{}, ()=>{ console.warn("Missing background.png"); });
    bgGlowImg = loadImage('backgroundglow.png', ()=>{}, ()=>{ console.warn("Missing backgroundglow.png"); });

    uiFrameImg = loadImage('ui_frame.png', ()=>{}, ()=>{ console.warn("Missing ui_frame.png"); });
    winnerFrameImg = loadImage('winnerframe.png', ()=>{}, ()=>{ console.warn("Missing winnerframe.png"); });

    bubbleImg = loadImage('bubble.png', ()=>{}, ()=>{ console.warn("Missing bubble.png"); });
    glowImg   = loadImage('bubbleglow.png', ()=>{}, ()=>{ console.warn("Missing bubbleglow.png"); });

    // pooled SFX (avoid stop/restart thrash)
    sfxFirePool   = [];
    sfxReloadPool = [];
    sfxBassPool   = [];
    sfxWooshPool  = [];
    for(let i=0;i<AUDIO_POOL_N;i++){
      sfxFirePool.push(loadSound('fire.mp3',   ()=>{}, ()=>console.warn("Missing fire.mp3")));
      sfxReloadPool.push(loadSound('reload.mp3', ()=>{}, ()=>console.warn("Missing reload.mp3")));
      sfxBassPool.push(loadSound('bass.wav',   ()=>{}, ()=>console.warn("Missing bass.wav")));
      sfxWooshPool.push(loadSound('woosh.wav', ()=>{}, ()=>console.warn("Missing woosh.wav")));
    }

    sfxWinner = loadSound('winner.mp3', ()=>{}, ()=>console.warn("Missing winner.mp3"));
    sfxMusic  = loadSound('music_loop.mp3', ()=>{}, ()=>console.warn("Missing music_loop.mp3"));
    sfxTension= loadSound('tension.wav',()=>{}, ()=>console.warn("Missing tension.wav"));

    sfxPop = [
      loadSound('pop1.mp3', ()=>{}, ()=>console.warn("Missing pop1.mp3")),
      loadSound('pop2.mp3', ()=>{}, ()=>console.warn("Missing pop2.mp3")),
      loadSound('pop3.mp3', ()=>{}, ()=>console.warn("Missing pop3.mp3")),
      loadSound('pop4.mp3', ()=>{}, ()=>console.warn("Missing pop4.mp3")),
    ];
  }

  async function setup(){
    createOrResizeCanvas();
    hookUI();
    await loadTodayRound();
    resetSim(true);
    updatePanelStatusThrottled(true);
    updateHudThrottled(true);
  }

  function windowResized(){ createOrResizeCanvas(); }

  function createOrResizeCanvas(){
    const targetH = Math.min(windowHeight, CFG.baseHeight);
    const targetW = targetH * (CFG.aspectW/CFG.aspectH);
    const w = Math.min(windowWidth, targetW);
    const h = w * (CFG.aspectH/CFG.aspectW);

    if(window._renderer && window._renderer.canvas) resizeCanvas(Math.floor(w), Math.floor(h));
    else createCanvas(Math.floor(w), Math.floor(h));

    const dpr = window.devicePixelRatio || 2;
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const pd = isIOS ? Math.min(1.75, dpr) : Math.min(2, dpr);
    pixelDensity(pd);

    try{
      drawingContext.imageSmoothingEnabled = true;
      drawingContext.imageSmoothingQuality = "high";
    }catch(_){}
  }

  function clipRect(x, y, w, h){
    const ctx = drawingContext;
    ctx.save(); ctx.beginPath(); ctx.rect(x, y, w, h); ctx.clip();
  }
  function unclip(){ drawingContext.restore(); }

  function hookUI(){
    hudEl = document.getElementById('hud');
    hudStatusEl = document.getElementById('hudStatus');
    panelEl = document.getElementById('panel');
    toastEl = document.getElementById('toast');
    controlsEl = document.getElementById('controls');

    panelRosterEl = document.getElementById('panelRoster');
    panelZorbEl = document.getElementById('panelZorb');
    panelAudioEl = document.getElementById('panelAudio');
    panelBackendEl = document.getElementById('panelBackend');
    panelSpritesEl = document.getElementById('panelSprites');
    startBtnEl = document.getElementById('startBtn');

    document.getElementById('btnMute').addEventListener('click', (ev)=>{
      ev.stopPropagation(); unlockAudioNow(); setMusicMuted(!musicMuted);
    });

    const modeBtnEl = document.getElementById('modeBtn');
    const offlineSelEl = document.getElementById('offlineCountSel');

    modeBtnEl.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      USE_BACKEND = !USE_BACKEND;
      modeBtnEl.textContent = USE_BACKEND ? "MODE: LIVE" : "MODE: OFFLINE";
      toastEl.textContent = USE_BACKEND ? "LIVE mode" : "OFFLINE test mode";
      toastPulse(); bumpUI();
      loadTodayRound();
    });

    offlineSelEl.addEventListener('change', (ev)=>{
      ev.stopPropagation();
      OFFLINE_COUNT = Number(offlineSelEl.value||250);
      if(!USE_BACKEND){
        toastEl.textContent = `OFFLINE: ${OFFLINE_COUNT}`;
        toastPulse();
        loadTodayRound();
      }
    });

    document.getElementById('btnShowPanel').addEventListener('click', (ev)=>{ ev.stopPropagation(); showPanel(true); showUI(true); });
    document.getElementById('btnPause').addEventListener('click', (ev)=>{ ev.stopPropagation(); togglePause(); bumpUI(); });
    document.getElementById('btnRestart').addEventListener('click', (ev)=>{ ev.stopPropagation(); resetSim(false); showUI(true); showPanel(true); });
    document.getElementById('btnHide').addEventListener('click', (ev)=>{ ev.stopPropagation(); setUIHidden(true); });

    document.getElementById('clearBtn').addEventListener('click', (ev)=>{
      ev.stopPropagation();
      resetSim(true);
      showPanel(true);
      showUI(true);
      updatePanelStatusThrottled(true);
      bumpUI();
    });

    startBtnEl.addEventListener('click', async (ev) => {
      ev.stopPropagation();
      unlockAudioNow();
      await loadTodayRound();
      resetSim(false);
      beginCountdown();
    });

    const gesture = ()=>{ unlockAudioNow(); };
    document.body.addEventListener('touchstart', gesture, { passive:true });
    document.body.addEventListener('pointerdown', gesture, { passive:true });

    // Audio recovery on focus/visibility for mobile browsers
    document.addEventListener("visibilitychange", ()=>{ if(!document.hidden) ensureAudioAlive(); });
    window.addEventListener("focus", ensureAudioAlive);

    document.body.addEventListener('click', ()=>{
      if(!panelEl.classList.contains('hidden')) return;
      if(uiHidden){ showUI(true); bumpUI(); return; }
      togglePause(); bumpUI();
    }, { passive:true });

    showPanel(true);
    showUI(true);
  }

  function showPanel(show){ panelEl.classList.toggle('hidden', !show); }
  function togglePause(){ if(simState !== "setup") paused = !paused; }

  function beginCountdown(){
    requestWakeLock();
    showPanel(false);
    if(hideTimer) clearTimeout(hideTimer);
    setUIHidden(true);
    paused = false;

    // Music stays on as constant atmosphere; tension stays muted until late game.
    setTimeout(() => {
      simState = "countdown";
      const startCount = Math.max(2, ARENA_START_COUNT || 50);
      countdownLabels = buildCountdownLabels(startCount);
      countdownFrames = Math.max(1, Math.floor(countdownLabels.length * 60));
      lastCountdownSec = -1;
    }, 120);
  }

  function showUI(withToast){ setUIHidden(false); if(withToast) toastPulse(); }
  function setUIHidden(hidden){
    uiHidden=hidden;
    hudEl.classList.toggle('hidden', hidden);
    controlsEl.classList.toggle('hidden', hidden);
  }
  function toastPulse(){
    toastEl.classList.add('show');
    setTimeout(()=>toastEl.classList.remove('show'), 1100);
  }
  function bumpUI(){
    if(hideTimer) clearTimeout(hideTimer);
    setUIHidden(false);
    if(simState === "setup") hideTimer = setTimeout(()=>setUIHidden(true), 1800);
  }

  async function requestWakeLock(){
    try{
      if(!('wakeLock' in navigator)) return;
      if(wakeLock) return;
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', ()=>{ wakeLock=null; });
    }catch(_){}
  }
  function releaseWakeLock(){
    try{ wakeLock?.release?.(); }catch(_){}
    wakeLock=null;
  }

  function getHandleForSpawn(nextId){
    const idx = (ARENA_START_COUNT - REMAINING_TOTAL) + (nextId-1);
    return rosterHandles[idx] || rosterHandles[nextId-1] || ("player" + nextId);
  }

  function getRobotX(){
    const sway = Math.sin(frameCount*CFG.robotSwaySpeedX) * (width*CFG.robotSwayFracX);
    const x = width*0.5 + sway;
    const estHalf = (zorbLoaded && zorbImg) ? (zorbImg.width*CFG.robotScale*0.52) : 120;
    const A = frameBounds();
    return constrain(x, A.L+estHalf+6, A.R-estHalf-6);
  }

  function cannonOrigins(){
    const robotX = getRobotX();
    const hoverY = Math.sin(frameCount*CFG.robotHoverSpeedY)*CFG.robotHoverAmpY;
    const sx = CFG.robotScale;
    const imgW = (zorbLoaded && zorbImg) ? zorbImg.width*sx : 320*sx;
    const imgH = (zorbLoaded && zorbImg) ? zorbImg.height*sx : 320*sx;
    const left = robotX - imgW*0.5;
    const top  = (zorb.y + hoverY) - imgH*0.5;
    const y = top + imgH*CFG.cannonYFrac;
    return CFG.cannonXFrac.map(fr => ({ x: left + imgW*fr, y }));
  }

  function createInitialPositionsGrid(count){
    const A = bubbleBounds();
    const cols = Math.max(8, Math.floor(Math.sqrt(count) * 1.25));
    const rows = Math.max(8, Math.ceil(count / cols));
    const cellW = A.W / cols;
    const cellH = A.H / rows;

    const pts = [];
    for(let r=0; r<rows; r++){
      for(let c=0; c<cols; c++){
        if(pts.length >= count) break;
        const x = A.L + cellW*(c+0.5) + random(-cellW*0.18, cellW*0.18);
        const y = A.T + cellH*(r+0.5) + random(-cellH*0.18, cellH*0.18);
        pts.push({x, y});
      }
      if(pts.length >= count) break;
    }
    for(let i=pts.length-1;i>0;i--){
      const j = Math.floor(random(i+1));
      const tmp = pts[i]; pts[i]=pts[j]; pts[j]=tmp;
    }
    return pts;
  }

  function spawnBubbleAt(nextId, x, y){
    const effectiveN = Math.min(totalRemaining(), players.length || PERF.maxSimBubbles);
    const size = getDynamicBubbleSize(effectiveN);
    const r = random(size.min, size.max);
    const handle = getHandleForSpawn(nextId);
    players.push(new Bubble(nextId, handle, x, y, r, random()));
  }

  function repositionBubble(b){
    const A = bubbleBounds();
    const r = b.r;
    for(let k=0;k<PERF.repositionAttempts;k++){
      b.x = random(A.L+r, A.R-r);
      b.y = random(A.T+r, A.B-r);
      if(k >= 4 && random() < 0.35) break;
    }
    b.v = createVector(random(-1,1), random(-1,1)).mult(random(0.6,1.6));
    b.noT = random(999);
  }

  // PERFORMANCE: when remaining is huge, reduce pop particles aggressively
  function particleScaleForRemaining(rem){
    if(rem >= 1200) return 0.00;
    if(rem >= 600)  return 0.10;
    if(rem >= 250)  return 0.22;
    if(rem >= 120)  return 0.50;
    return 1.00;
  }

  // VISUAL ONLY (audio handled per-burst in stepFixed)
  function popBubbleFX(b){
    if(simState==="running"){
      frameShake = Math.min(CFG.shakeCap, Math.max(frameShake, CFG.screenShakePop*(totalRemaining()<=5?1.2:1.0)));
    }

    const rem = totalRemaining();
    const m = particleScaleForRemaining(rem);
    if(m <= 0) return;

    const maxParticles = (rem >= 250) ? 1600 : 4200;
    if(particles.length > maxParticles){
      particles.splice(0, particles.length - maxParticles);
    }

    const sparks = Math.max(1, Math.floor(CFG.popParticles * m));
    const pops   = Math.max(1, Math.floor(6 * m));

    for(let i=0;i<sparks;i++){
      const v=p5.Vector.random2D().mult(random(2.0,6.2));
      v.y += 0.9;
      particles.push(new Particle(b.x,b.y,v.x,v.y,CFG.sparkLife,'spark'));
    }
    for(let i=0;i<pops;i++){
      const v=p5.Vector.random2D().mult(random(1.0,4.6));
      particles.push(new Particle(b.x,b.y,v.x,v.y,CFG.popLife,'pop'));
    }
  }

  // 1 sound per elimination burst (not per bubble)
  function playBurstSfx(elimCount, remBefore){
    if(!audioUnlocked) return;
    const now = performance.now();
    if(now - lastBurstSfxMs < BURST_SFX_COOLDOWN_MS) return;
    if(!takePopToken()) return;

    lastBurstSfxMs = now;

    // choose ONE pop sound + ONE bass accent (optional) per burst
    try{
      const snd = random(sfxPop);
      if(snd && !(snd.isPlaying && snd.isPlaying())){
        snd.amp(SFX.master * SFX.pop, 0);
        snd.play();
      }
    }catch(_){}

    // Bass probability ramps up as it gets smaller
    const rem = Math.max(1, remBefore);
    const bassChance =
      (rem <= 10) ? 1.00 :
      (rem <= 20) ? 0.70 :
      (rem <= 50) ? 0.40 :
      (rem <= 120) ? 0.25 :
      0.12;

    if(random() < bassChance){
      playFromPool(sfxBassPool, "bass", SFX.bass * (elimCount >= 4 ? 1.05 : 1.0));
    }
  }

  // milestone accents (optional but cheap)
  function maybePlayMilestone(remAfter){
    for(const m of MILESTONES){
      if(remAfter <= m && !hitMilestones.has(m)){
        hitMilestones.add(m);
        // single bass "thump"
        if(audioUnlocked && takePopToken()){
          playFromPool(sfxBassPool, "bass", SFX.bass * 1.15);
        }
        break;
      }
    }
  }

  // Key scalability: fixed pool & recycle while remaining is huge
  function eliminateAtIndex(i){
    if(players.length <= 0) return false;

    if(REMAINING_TOTAL > PERF.recycleModeThreshold){
      const b = players[i];
      if(!b) return false;

      popBubbleFX(b);
      REMAINING_TOTAL = Math.max(0, REMAINING_TOTAL - 1);

      const newId = NEXT_SPAWN_ID++;
      b.id = newId;
      b.handle = getHandleForSpawn(newId);
      b.label = b.handle ? ("@"+b.handle) : ("#"+b.id);
      b.rSeed = random();
      repositionBubble(b);
      return true;
    }

    const b = players[i];
    if(!b) return false;
    popBubbleFX(b);
    REMAINING_TOTAL = Math.max(0, REMAINING_TOTAL - 1);

    const last = players.length - 1;
    if(i !== last) players[i] = players[last];
    players.pop();
    return true;
  }

  function resetSim(keepSetupState){
    stopAllAudio();

    players=[]; projectiles=[]; particles=[]; frameShake=0;
    paused=false; winnerPlayed=false;
    winnerMomentFrames = 0;
    accumMs = 0;

    elimBudget = 0;
    lastBurstSfxMs = 0;
    lastWooshSfxMs = 0;

    popTokens = 0;
    shotTokens = 0;

    finalePulseT = 0;
    hitMilestones.clear();

    zorb.y = height * CFG.robotY + dy(CFG.robotYOffsetDesign);
    zorb.aimX = width * 0.5;
    zorb.aimY = height * 0.5;
    zorb.recoil = 0;
    zorb.fireCooldown = 0;

    simState = keepSetupState ? "setup" : simState;
    countdownFrames = 0;

    const finalCount = USE_BACKEND
      ? Math.max(1, Math.min(5000000, Number(ROUND_META?.finale_count||rosterHandles.length||50)))
      : Math.max(1, Number(OFFLINE_COUNT||250));

    ARENA_START_COUNT = finalCount;
    REMAINING_TOTAL = finalCount;

    const simCount = Math.min(finalCount, PERF.maxSimBubbles);
    NEXT_SPAWN_ID = simCount + 1;

    const pts = createInitialPositionsGrid(simCount);
    for(let i=0;i<simCount;i++){
      const p = pts[i] || {x: width*0.5, y: height*0.6};
      spawnBubbleAt(i+1, p.x, p.y);
    }

    updatePanelStatusThrottled(true);
    updateHudThrottled(true);
  }

  function draw(){
    if(!paused){
      const dt = Math.min(50, deltaTime || 16);
      accumMs += dt;
      let steps = 0;
      while(accumMs >= FIXED_DT_MS && steps < 4){
        stepFixed(FIXED_DT_MS/1000);
        accumMs -= FIXED_DT_MS;
        steps++;
      }
    }
    render();
    updateHudThrottled(false);
  }

  function buildGrid(){
    const cs = PERF.cellSize;
    const grid = new Map();
    for(let i=0;i<players.length;i++){
      const b = players[i];
      const cx = Math.floor(b.x / cs);
      const cy = Math.floor(b.y / cs);
      const key = cx + "," + cy;
      let arr = grid.get(key);
      if(!arr){ arr=[]; grid.set(key, arr); }
      arr.push(i);
      b._cx = cx; b._cy = cy;
    }
    return grid;
  }

  function neighborPairs(grid){
    for(let i=0;i<players.length;i++){
      const a = players[i];
      for(let oy=-1; oy<=1; oy++){
        for(let ox=-1; ox<=1; ox++){
          const key = (a._cx+ox)+","+(a._cy+oy);
          const arr = grid.get(key);
          if(!arr) continue;
          for(let k=0;k<arr.length;k++){
            const j = arr[k];
            if(j <= i) continue;
            players[i].separate(players[j]);
          }
        }
      }
    }
  }

  function naturalDurationForStart(start){
    if(start <= 10)  return 7;
    if(start <= 25)  return 10;
    if(start <= 60)  return 14;
    if(start <= 120) return 18;
    if(start <= 250) return 22;
    return 28;
  }
  function effectiveDurationForStart(start){
    return Math.min(BATTLE_TIME_CAP_SEC, naturalDurationForStart(start));
  }
  function popsPerSecondBase(){
    const start = Math.max(2, ARENA_START_COUNT || 50);
    const needed = Math.max(1, start - 1);
    return needed / effectiveDurationForStart(start);
  }
  function dramaMultiplier(rem, start){
    const u = constrain((rem - 1) / Math.max(1, start - 1), 0, 1);
    const eased = pow(u, 1.35);
    return 0.35 + 0.65 * eased;
  }

  // "Burst eliminations based on remaining count"
  function burstSizeForRemaining(rem){
    if(rem >= 2500) return 8;
    if(rem >= 1200) return 6;
    if(rem >= 600)  return 4;
    if(rem >= 250)  return 3;
    if(rem >= 120)  return 2;
    return 1;
  }

  function fastEliminateOne(){
    if(players.length <= 1) return false;
    const victimIdx = Math.floor(random(players.length));
    const v = players[victimIdx];
    if(!v) return false;

    // aim animation only (no per-elim fire/reload sounds in burst mode)
    zorb.aimX = v.x + random(-CFG.aimJitter, CFG.aimJitter);
    zorb.aimY = v.y + random(-CFG.aimJitter, CFG.aimJitter);
    zorb.recoil = 0.35;

    return eliminateAtIndex(victimIdx);
  }

  function pickTarget(){
    const b = players.length ? random(players) : null;
    return b ? { x:b.x, y:b.y, bubble:b } : { x:width*0.5, y:height*0.6 };
  }

  function fireShot(){
    const origin = random(cannonOrigins());
    const dir = createVector(zorb.aimX-origin.x, zorb.aimY-origin.y).normalize();
    const vel = dir.mult(CFG.projectileSpeed);

    if(projectiles.length >= PERF.maxProjectiles) projectiles.splice(0, projectiles.length - PERF.maxProjectiles + 1);
    projectiles.push(new Projectile(origin.x, origin.y, vel.x, vel.y));

    // Fire/reload only during "true shots" late game
    if(takeShotToken()){
      playFromPool(sfxFirePool, "fire", SFX.fire);
      playFromPool(sfxReloadPool, "reload", SFX.reload);
    }

    zorb.recoil = 1.0;
    if(simState==="running"){
      frameShake = Math.min(CFG.shakeCap, Math.max(frameShake, CFG.screenShakeShot*(totalRemaining()<=5?1.0:0.8)));
    }
  }

  function stepFixed(dt){
    ensureAudioAlive();
    zorb.recoil *= 0.86;

    const remainingBefore = totalRemaining();

    // refill audio budgets every sim tick
    refillSfxTokens(dt, remainingBefore);

    for(const b of players) b.update();
    if(players.length > 1){
      const grid = buildGrid();
      neighborPairs(grid);
    }

    for(let i=projectiles.length-1;i>=0;i--){
      projectiles[i].update(dt);
      if(projectiles[i].dead) projectiles.splice(i,1);
    }
    for(let i=particles.length-1;i>=0;i--){
      particles[i].update();
      if(particles[i].dead) particles.splice(i,1);
    }

    // tension loop late game
    tensionTarget = (remainingBefore<=10 && simState==="running") ? 1 : 0;
    tensionVol = lerp(tensionVol, tensionTarget, 0.02);
    if(audioUnlocked && sfxTension){
      try{ sfxTension.amp(SFX.master*SFX.tensionMax*tensionVol, 0.05); }catch(_){}
    }

    if(simState==="countdown"){
      countdownFrames -= 1;
      if(countdownFrames<=0){
        simState="running";
        countdownFrames=0;
        // music already running
      }
      return;
    }
    if(simState!=="running") return;

    const start = Math.max(2, ARENA_START_COUNT || 50);
    const pps = popsPerSecondBase() * dramaMultiplier(remainingBefore, start);
    elimBudget += pps * dt;
    elimBudget = Math.min(elimBudget, 12);

    const useDirect = (remainingBefore > DIRECT_POP_THRESHOLD);
    let elimThisTick = 0;

    // burst eliminations (single burst SFX for the group)
    const burstN = burstSizeForRemaining(remainingBefore);
    const toDo = Math.min(Math.floor(elimBudget), burstN);

    for(let k=0; k<toDo && totalRemaining() > 1; k++){
      if(useDirect){
        if(fastEliminateOne()) elimThisTick++;
      }else{
        if(zorb.fireCooldown <= 0){
          const t = pickTarget();
          zorb.aimMeta = t;
          zorb.aimX = t.x + random(-CFG.aimJitter, CFG.aimJitter);
          zorb.aimY = t.y + random(-CFG.aimJitter, CFG.aimJitter);
          fireShot();
          zorb.fireCooldown = 0.12;
        }else{
          if(fastEliminateOne()) elimThisTick++;
        }
      }
      elimBudget -= 1;
    }

    // Burst SFX: once per tick if we eliminated anything
    if(elimThisTick > 0){
      playBurstSfx(elimThisTick, remainingBefore);
      maybePlayMilestone(totalRemaining());
    }

    zorb.fireCooldown = Math.max(0, zorb.fireCooldown - dt);

    // Finale winner
    if(totalRemaining()===1 && players.length===1){
      if(simState !== "finished"){
        simState="finished";
        winnerMomentFrames = WINNER_MOMENT_LEN;
      }
      if(!winnerPlayed){
        winnerPlayed=true;
        duckMusic();
        playOne(sfxWinner, SFX.winner);

        (async () => {
          try { await reportWinnerToBackend(players[0]); } catch(e){ console.warn(e); }
          finally { releaseWakeLock(); }
        })();
      }
    }

    // pulse time for glow overlay
    if(totalRemaining() <= 10 && simState==="running"){
      const rem = Math.max(1, totalRemaining());
      const speed = (rem <= 5) ? 0.018 : 0.010; // faster for final 5
      finalePulseT += speed;
    }else{
      finalePulseT *= 0.98;
    }
  }

  function drawFinaleGlowOverlay(){
    if(!bgGlowImg) return;
    const rem = totalRemaining();
    if(!(simState==="running" || simState==="finished")) return;
    if(rem > 10) return;

    // dramatic pulse: stronger as it gets smaller
    const t = finalePulseT;
    const pulse = 0.5 + 0.5*Math.sin(t * 2.0);
    const strength = (rem <= 5) ? (0.45 + pulse*0.40) : (0.25 + pulse*0.25);
    const alpha = 255 * constrain(strength, 0, 0.95);

    push();
    blendMode(SCREEN);   // brightens without muddying
    tint(255, 255, 255, alpha);
    image(bgGlowImg, 0, 0, width, height);
    blendMode(BLEND);
    noTint();
    pop();
  }

  function render(){
    background(0);
    const A = frameBounds();
    clipRect(A.L, A.T, A.W, A.H);

    background(CFG.bgColor);
    if (bgImg) image(bgImg, 0, 0, width, height);

    // NEW: dramatic pulsing overlay for final 10 (especially final 5)
    drawFinaleGlowOverlay();

    if(CFG.vignette) drawVignette();

    let sx=0, sy=0;
    if(frameShake>0 && !paused && simState==="running"){
      sx = random(-frameShake, frameShake);
      sy = random(-frameShake, frameShake);
      frameShake *= CFG.shakeDecay;
      if(frameShake < 0.05) frameShake = 0;
    }

    push();
    translate(sx, sy);

    for(const b of players) b.draw();
    for(const pt of particles) pt.draw();
    for(const p of projectiles) p.draw();

    drawSoftCeilingFade();
    drawZorb();
    if(simState==="countdown") drawCountdown();

    if(simState==="finished" && players.length===1){
      if(winnerMomentFrames > 0){
        drawWinnerMoment(players[0]);
        winnerMomentFrames--;
      }else{
        drawWinnerCard(players[0]);
      }
    }

    pop();
    unclip();

    if(simState!=="finished") drawUIFrameOverlayExact();
    if(simState!=="finished") drawTopBannerTextBoxes();
  }

  function drawUIFrameOverlayExact(){
    if(!uiFrameImg) return;
    push(); imageMode(CORNER); image(uiFrameImg, 0, 0, width, height); pop();
  }

  function drawVignette(){
    noFill();
    for(let i=0;i<12;i++){
      stroke(0,0,0,14);
      rect(-i,-i, width+2*i, height+2*i, 22);
    }
  }

  function drawTextInBox(str, x, y, w, h, align){
    push();
    textFont("system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif");
    textStyle(BOLD);
    const pad = Math.max(6, w*0.08);

    drawingContext.save();
    drawingContext.beginPath();
    drawingContext.rect(x, y, w, h);
    drawingContext.clip();

    fill(255,255,255,232);
    noStroke();

    let ts = Math.min(26, h * 0.62);
    const minTs = 8;

    textSize(ts);
    while(textWidth(str) > (w - pad*2) && ts > minTs){
      ts -= 1;
      textSize(ts);
    }

    if(textWidth(str) > (w - pad*2)){
      const short = str.replace(/^PLAYERS\s+/i, "");
      textSize(ts);
      if(textWidth(short) <= (w - pad*2)) str = short;
    }

    textAlign(align==="right" ? RIGHT : align==="center" ? CENTER : LEFT, CENTER);
    const tx = align==="right" ? (x + w - pad) : align==="center" ? (x + w/2) : (x + pad);
    const ty = y + h/2;
    text(str, tx, ty);

    drawingContext.restore();
    pop();
  }

  function drawTopBannerTextBoxes(){
    const boxW = dw(CFG.bannerBoxWDesign);
    const boxH = dh(CFG.bannerBoxHDesign);
    const insetX = dx(CFG.bannerInsetXDesign);
    const topY  = dy(CFG.bannerTopYDesign);
    const leftX = insetX;
    const rightX= width - insetX - boxW;

    const n = totalRemaining();
    const a = ARENA_START_COUNT || n;
    const leftLabel = (a >= 1000) ? `${n}/${a}` : `PLAYERS ${n}/${a}`;

    drawTextInBox(leftLabel, leftX, topY, boxW, boxH, "center");
    drawTextInBox(`ROUND ${ROUND_META?.round_number || 2}`, rightX, topY, boxW, boxH, "center");
  }

  function drawZorb(){
    const robotX = getRobotX();
    const hoverY = Math.sin(frameCount*CFG.robotHoverSpeedY)*CFG.robotHoverAmpY;
    const scaleAmt = CFG.robotScale*(1 + zorb.recoil*0.01);

    if(zorbLoaded && zorbImg){
      push();
      imageMode(CENTER);
      tint(255,255,255,245);
      image(zorbImg, robotX, zorb.y+hoverY, zorbImg.width*scaleAmt, zorbImg.height*scaleAmt);
      pop();
    }

    for(const o of cannonOrigins()){
      noStroke(); fill(255,220,0,12); circle(o.x,o.y,12);
    }
  }

  function drawCountdown(){
    const secLeft = ceil(countdownFrames/60);
    const idx = (countdownLabels && countdownLabels.length) ? (countdownLabels.length - secLeft) : 0;
    const label = (countdownLabels && countdownLabels.length) ? countdownLabels[constrain(idx, 0, countdownLabels.length-1)] : String(secLeft);

    if(secLeft !== lastCountdownSec){
      lastCountdownSec = secLeft;
      playWooshThrottled();
    }

    noStroke();
    fill(0,0,0,120);
    rect(0,0,width,height);

    const phase = (countdownFrames % 60) / 60;
    const bounce = 1 + 0.18 * pow(1 - phase, 2);

    const cx = width*0.5, cy = height*0.50;
    push();
    translate(cx, cy);
    scale(bounce);

    textAlign(CENTER,CENTER);
    fill(255,255,255,255);
    textSize(label === "GO!" ? 92 : (label === "READY?" ? 72 : 82));
    text(label, 0, 0);
    pop();

    countdownFrames--;
  }

  function drawWinnerMoment(b){
    const t = (WINNER_MOMENT_LEN - winnerMomentFrames) / WINNER_MOMENT_LEN;
    const popScale = 1 + 0.10 * Math.sin(Math.min(1, t) * Math.PI);
    const aspect = (CFG.bubbleSpriteH / CFG.bubbleSpriteW) || 1;

    push();
    translate(b.x, b.y);
    const sW = (b.r*2) * popScale;
    const sH = sW * aspect;

    if(glowImg){
      imageMode(CENTER);
      tint(255,255,255, 220);
      image(glowImg, 0, 0, sW, sH);
      noTint();
    }else if(bubbleImg){
      imageMode(CENTER);
      image(bubbleImg, 0, 0, sW, sH);
    }
    pop();
  }

  function drawWinnerCard(b){
    background(0);
    const A = frameBounds();
    clipRect(A.L, A.T, A.W, A.H);

    background(6,4,12);
    if(bgImg) image(bgImg, 0, 0, width, height);

    if(winnerFrameImg){
      push();
      imageMode(CORNER);
      image(winnerFrameImg, A.L, A.T, A.W, A.H);
      pop();
    }

    const nameRaw = (b && b.handle) ? ("@" + b.handle) : String(b?.id ?? "WINNER");

    const wfW = (winnerFrameImg && winnerFrameImg.width) ? winnerFrameImg.width : DESIGN.w;
    const wfH = (winnerFrameImg && winnerFrameImg.height) ? winnerFrameImg.height : DESIGN.h;

    const nameX = A.L + (A.W * (CFG.winnerNameCenterXDesign / wfW));
    const nameY = A.T + (A.H * (CFG.winnerNameCenterYDesign / wfH));
    const maxW  = A.W * (CFG.winnerNameMaxWDesign / wfW);

    textAlign(CENTER, CENTER);
    let ts = min(72, maxW * 0.18);
    textSize(ts);
    while(textWidth(nameRaw) > maxW && ts > 22){
      ts -= 2;
      textSize(ts);
    }

    stroke(0,0,0,220);
    strokeWeight(10);
    fill(255);
    text(nameRaw, nameX, nameY);

    const ctaX = A.L + A.W * 0.50;
    const ctaY = A.T + A.H * 0.68;
    const ctaMaxW = A.W * 0.80;

    const lines = ['Follow @Zorbi.ai','Comment "IN"','Enter The Arena'];

    let ctaSize = 22;
    textAlign(CENTER, CENTER);
    textFont("system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif");
    textSize(ctaSize);

    while(lines.some(L => textWidth(L) > ctaMaxW) && ctaSize > 14){
      ctaSize -= 1;
      textSize(ctaSize);
    }

    const lineH = ctaSize * 1.25;
    const blockH = lineH * lines.length;
    const startY = ctaY - blockH/2 + lineH/2;

    stroke(0,0,0,235);
    strokeWeight(7);
    fill(255,255,255,245);

    for(let i=0;i<lines.length;i++){
      text(lines[i], ctaX, startY + i*lineH);
    }

    unclip();
  }

  class Bubble{
    constructor(id, handle, x, y, r, rSeed=0.5){
      this.id=id;
      this.handle=handle||null;
      this.x=x; this.y=y; this.r=r;
      this.rSeed = rSeed;

      this.v=createVector(random(-1,1), random(-1,1)).mult(random(0.6,1.6));
      this.spin=random([-1,1])*random(0.8,1.35);
      this.swirl=random(0.6,1.4);
      this.noT = random(999);

      this.label = this.handle ? ("@"+this.handle) : ("#"+this.id);
    }

    update(){
      const effectiveN = Math.min(players.length, totalRemaining());
      const size = getDynamicBubbleSize(effectiveN);
      const targetR = lerp(size.min, size.max, this.rSeed);
      this.r = lerp(this.r, targetR, 0.08);

      this.noT += 0.010;
      const n1 = noise(this.x*0.0020, this.y*0.0020, this.noT);
      const n2 = noise(this.y*0.0020, this.x*0.0020, this.noT+40);
      this.v.x += (n1-0.5) * CFG.wanderForce;
      this.v.y += (n2-0.5) * CFG.wanderForce;

      const cx=width*0.5, cy=height*0.58;
      const toC=createVector(cx-this.x, cy-this.y);
      const tangent=createVector(-toC.y, toC.x).normalize()
        .mult(CFG.swirlStrength*this.spin*this.swirl);
      this.v.add(tangent);

      if(random() < CFG.swirlJukeChance){
        const j=p5.Vector.random2D().mult(CFG.swirlJukeForce*random(0.7,1.2));
        this.v.add(j);
      }

      const maxV = CFG.maxSpeed;
      const m = this.v.mag();
      if(m>maxV) this.v.mult(maxV/m);

      this.x += this.v.x;
      this.y += this.v.y;

      const A = bubbleBounds();
      const artPad = Math.max(3, this.r * 0.12);
      const eff = this.r * CFG.bubbleDrawScale + artPad;

      if(this.x < A.L + eff){ this.x=A.L + eff; this.v.x*=-1; }
      if(this.x > A.R - eff){ this.x=A.R - eff; this.v.x*=-1; }
      if(this.y < A.T + eff){ this.y=A.T + eff; this.v.y*=-1; }
      if(this.y > A.B - eff){ this.y=A.B - eff; this.v.y*=-1; }

      this.v.mult(CFG.bounceDamping);
    }

    separate(other){
      const dx=other.x-this.x, dy=other.y-this.y;
      const d2=dx*dx+dy*dy;
      const minD=this.r+other.r+8;
      const minD2=minD*minD;
      if(d2>0 && d2<minD2){
        const d=Math.sqrt(d2);
        const overlap=(minD-d)/minD;
        const push=overlap*CFG.separationStrength;
        const nx=dx/d, ny=dy/d;

        this.x -= nx*push*40; this.y -= ny*push*40;
        other.x += nx*push*40; other.y += ny*push*40;

        this.v.x -= nx*push*1.2; this.v.y -= ny*push*1.2;
        other.v.x += nx*push*1.2; other.v.y += ny*push*1.2;
      }
    }

    draw(){
      const rem = totalRemaining();
      const alpha = (rem > CFG.namesFadeStartN) ? 0 : (rem <= CFG.namesFadeFullN ? 255 : map(rem, CFG.namesFadeStartN, CFG.namesFadeFullN, 0, 255));

      const aspect = (CFG.bubbleSpriteH / CFG.bubbleSpriteW) || 1;
      const sW = this.r*2 * CFG.bubbleDrawScale;
      const sH = sW * aspect;

      const useGlowSprite = (rem <= CFG.glowSwapFinalN) && !!glowImg;

      push();
      translate(this.x, this.y);
      imageMode(CENTER);

      if(useGlowSprite){
        tint(255,255,255,235);
        image(glowImg, 0, 0, sW, sH);
        noTint();
      }else if(bubbleImg){
        image(bubbleImg, 0, 0, sW, sH);
      }else{
        noStroke();
        fill(255,255,255,18);
        circle(0,0,sW);
      }

      if(alpha > 0){
        const maxW = sW * 0.78;
        const maxH = sH * 0.26;

        const spriteHalfH = CFG.bubbleSpriteH * 0.5;
        const spriteDeltaY = (CFG.bubbleContentCenterYPx - spriteHalfH) / CFG.bubbleSpriteH;
        const yOff = (spriteDeltaY * sH) + (CFG.bubbleLabelExtraYOffset || 0);

        push();
        translate(0, yOff);

        let ts = max(10, min(24, maxH * 0.85));
        textAlign(CENTER, CENTER);
        textFont("system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif");
        textSize(ts);
        while((textWidth(this.label) > maxW || ts > maxH) && ts > 10){
          ts -= 1; textSize(ts);
        }
        stroke(0,0,0, min(235, alpha));
        strokeWeight(max(3, ts * 0.22));
        fill(255,255,255, min(250, alpha));
        text(this.label, 0, 0);
        pop();
      }

      pop();
    }
  }

  class Projectile{
    constructor(x,y,vx,vy){
      this.x=x; this.y=y;
      this.v=createVector(vx,vy);
      this.r=CFG.projectileRadius;
      this.dead=false;
    }
    update(dt){
      this.x += this.v.x;
      this.y += this.v.y;

      if(this.y > height+120 || this.x < -120 || this.x > width+120){
        this.dead=true; return;
      }

      for(let i=players.length-1;i>=0;i--){
        const b=players[i];
        const dx=this.x-b.x, dy=this.y-b.y;
        if(dx*dx+dy*dy < (b.r + this.r)*(b.r + this.r)){
          eliminateAtIndex(i);
          this.dead=true;
          break;
        }
      }
    }
    draw(){
      noStroke();
      fill(255,120,0,40); circle(this.x,this.y,this.r*3.6);
      fill(255,240,120,220); circle(this.x,this.y,this.r*1.6);
    }
  }

  class Particle{
    constructor(x,y,vx,vy,life,kind='spark'){
      this.x=x; this.y=y;
      this.v=createVector(vx,vy);
      this.life=life; this.maxLife=life;
      this.kind=kind;
      this.dead=false;
      this.r=(kind==='pop') ? random(3,7) : random(2,4);
    }
    update(){
      this.x += this.v.x;
      this.y += this.v.y;
      this.v.mult(0.93);
      this.life -= 1;
      if(this.life<=0) this.dead=true;
    }
    draw(){
      const a = map(this.life, 0, this.maxLife, 0, 255);
      noStroke();
      if(this.kind==='pop') fill(255,255,255,a);
      else fill(255,80,240,a);
      circle(this.x,this.y,this.r);
    }
  }

  async function reportWinnerToBackend(b) {
    const payload = { winner: b.handle || ("#" + b.id), winnerSlot: b.id };
    try {
      await fetch(WINNER_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      console.log("Winner saved ✅");
      return true;
    } catch (e) {
      console.warn("Winner POST failed:", e);
      return false;
    }
  }

  function updatePanelStatus(){
    const finalCount = ARENA_START_COUNT || (USE_BACKEND ? (ROUND_META?.finale_count||50) : OFFLINE_COUNT);
    panelRosterEl.textContent = `Roster: ${finalCount} entrants`;
    panelZorbEl.textContent = zorbLoaded ? "Zorb: OK" : "Zorb: missing";
    panelZorbEl.classList.toggle('ok', zorbLoaded);
    panelZorbEl.classList.toggle('warn', !zorbLoaded);

    panelAudioEl.textContent = audioUnlocked ? "Audio: unlocked" : "Audio: locked";
    panelAudioEl.classList.toggle('ok', audioUnlocked);
    panelAudioEl.classList.toggle('warn', !audioUnlocked);

    panelBackendEl.textContent = USE_BACKEND ? (BACKEND_OK ? `Backend: OK` : "Backend: offline") : `Mode: OFFLINE`;
    panelBackendEl.classList.toggle('ok', (!USE_BACKEND) || BACKEND_OK);
    panelBackendEl.classList.toggle('bad', USE_BACKEND && !BACKEND_OK);

    spritesOk = !!(bubbleImg && glowImg);
    panelSpritesEl.textContent = spritesOk ? "Sprites: OK" : "Sprites: missing";
    panelSpritesEl.classList.toggle('ok', spritesOk);
    panelSpritesEl.classList.toggle('warn', !spritesOk);

    startBtnEl.disabled = false;
  }

  function updateHud(){
    const z = zorbLoaded ? "ok" : "MISSING zorb.png";
    const a = audioUnlocked ? "unlocked" : "locked";
    const state =
      (simState==="setup") ? "SETUP" :
      (simState==="countdown") ? "COUNTDOWN" :
      (simState==="running") ? "RUNNING" : "FINISH";

    const rd = ROUND_META?.round_date ? ` • ${ROUND_META.round_date}` : "";
    const mode = ROUND_META?.mode ? ` • ${ROUND_META.mode}` : "";
    const backend = BACKEND_OK ? " • backend OK" : " • backend offline";
    const cd = (simState==="countdown") ? ` • starts in ${ceil(countdownFrames/60)}s` : "";

    hudStatusEl.textContent =
      `State: ${state}${rd}${mode}${backend} • Zorb: ${z} • Audio: ${a}` +
      ` • Remaining: ${totalRemaining()}${cd}` +
      (paused ? " • PAUSED" : "");
  }

  function updatePanelStatusThrottled(force=false){
    const now = performance.now();
    if(force || now - lastPanelUpdateMs > 800){
      lastPanelUpdateMs = now;
      updatePanelStatus();
    }
  }
  function updateHudThrottled(force=false){
    const now = performance.now();
    if(force || now - lastHudUpdateMs > 250){
      lastHudUpdateMs = now;
      updateHud();
      updatePanelStatusThrottled(false);
    }
  }
  </script>
</body>
</html>
