<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Zorbblez – Mobile Full v3</title>
  <style>
    :root {
      --bg: #0B0F1F;
      --panel: rgba(0,0,0,0.35);
      --panel2: rgba(0,0,0,0.58);
      --stroke: rgba(255,255,255,0.14);
      --text: rgba(255,255,255,0.92);
      --btn: rgba(255,255,255,0.11);
      --btnHover: rgba(255,255,255,0.18);
      --good: rgba(120,255,170,0.92);
      --warn: rgba(255,210,120,0.92);
    }
    html, body { margin:0; padding:0; background:var(--bg); overflow:hidden; height:100%; }
    canvas { display:block; margin:0 auto; touch-action:none; }

    #hud {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text); font-size: 12px; line-height: 1.25;
      background: var(--panel); border: 1px solid var(--stroke);
      padding: 10px 12px; border-radius: 12px; backdrop-filter: blur(10px);
      max-width: 390px;
    }
    #hud b { font-size: 13px; }
    #hud .tiny { opacity:0.78; font-size: 11px; margin-top: 6px; }

    #panel {
      position: fixed; left: 50%; top: 50%; transform: translate(-50%,-50%);
      z-index: 30;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--panel2); border: 1px solid rgba(255,255,255,0.18);
      padding: 18px 18px 14px; border-radius: 16px;
      color: var(--text);
      width: min(92vw, 460px);
      text-align: center;
      backdrop-filter: blur(12px);
    }
    #panel h1 { font-size: 18px; margin: 0 0 10px; }
    #panel p { margin: 8px 0; font-size: 12px; opacity: 0.92; line-height: 1.35; }
    #panel input { display:none; }
    #panel .row { display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:10px; }
    #panel .note { font-size:11px; opacity:0.75; margin-top:10px; }
    #panel .status { margin-top: 10px; font-size: 12px; opacity:0.95; }
    #panel .pill { display:inline-block; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,0.16); background: rgba(255,255,255,0.08); }
    #panel .ok { color: var(--good); }
    #panel .warn { color: var(--warn); }

    #controls {
      position: fixed; left: 50%; bottom: 14px; transform: translateX(-50%);
      z-index: 25;
      display: flex; gap: 10px;
      padding: 10px;
      border-radius: 18px;
      background: var(--panel2);
      border: 1px solid rgba(255,255,255,0.16);
      backdrop-filter: blur(14px);
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }
    .btn {
      appearance: none; border: 1px solid rgba(255,255,255,0.18);
      background: var(--btn);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      font-size: 13px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      cursor: pointer;
      min-width: 64px;
    }
    .btn:active { transform: translateY(1px); background: var(--btnHover); }
    .btn.small { min-width: 52px; padding: 10px 10px; }
    .btn.wide { min-width: 110px; }
    .btn.primary { border-color: rgba(120,255,170,0.35); background: rgba(120,255,170,0.12); }

    .hidden { display:none !important; }

    #toast {
      position: fixed; left: 50%; top: 14px; transform: translateX(-50%);
      z-index: 40;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 12px;
      color: var(--text);
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.14);
      padding: 8px 10px;
      border-radius: 999px;
      backdrop-filter: blur(10px);
      opacity: 0;
      transition: opacity 220ms ease;
      pointer-events: none;
    }
    #toast.show { opacity: 1; }
  </style>
</head>
<body>
  <div id="toast">UI shown • will auto-hide for recording</div>

  <div id="hud">
    <b>Zorbblez – Top 50</b>
    <div id="hudStatus">Loading…</div>
    <div class="tiny">Tap background: pause/resume • Tap anywhere when UI hidden: show UI</div>
  </div>

  <div id="panel">
    <h1>Load today’s Top 50</h1>
    <p>Select up to <b>50</b> profile images. Then press <b>Start</b> to begin the countdown.</p>

    <div class="row">
      <label class="btn wide" style="display:inline-block;">
        Choose images
        <input id="fileInput" type="file" accept="image/*" multiple />
      </label>

      <button class="btn wide" id="startNumbers" type="button">Start with numbers</button>
    </div>

    <div class="row">
      <button class="btn wide primary" id="startBtn" type="button" disabled>Start</button>
      <button class="btn wide" id="clearBtn" type="button">Clear</button>
    </div>

    <div class="status">
      <span class="pill" id="panelRoster">Roster: numbers</span>
      <span class="pill" id="panelZorb">Zorb: …</span>
    </div>

    <div class="note">Tip: after you press Start, the UI will auto-hide in ~2s for clean screen recording.</div>
  </div>

  <div id="controls">
    <button class="btn wide" id="btnShowPanel" type="button">Roster</button>
    <button class="btn" id="btnPause" type="button">Pause</button>
    <button class="btn" id="btnRestart" type="button">Restart</button>
    <button class="btn small" id="btnChaosDown" type="button">–</button>
    <button class="btn small" id="btnChaosUp" type="button">+</button>
    <button class="btn wide" id="btnHide" type="button">Hide UI</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
  <script>
  const CFG = {
    aspectW: 9, aspectH: 16,
    baseHeight: 1280,
    bgColor: '#0B0F1F',
    vignette: true,

    playerCount: 50,
    bubbleMinR: 42,
    bubbleMaxR: 58,
    bubbleGlow: 18,

    wanderForce: 0.12,
    maxSpeed: 2.05,
    bounceDamping: 0.985,
    separationStrength: 0.26,

    // ZORB SIZE + MOTION
    robotScale: 0.15,
    robotY: 0.18,
    robotHoverAmpY: 8,
    robotHoverSpeedY: 0.028,
    robotSwayFracX: 0.08,
    robotSwaySpeedX: 0.018,

    // Cannon alignment (tweak these for perfect alignment)
    cannonXFrac: [0.34, 0.50, 0.66],
    cannonYFrac: 0.80,

    chargeTime: 10,
    fireRate: 0.75,
    fireRateFinal: 0.34,
    fireRateFinal2: 0.20,

    aimJitter: 16,
    projectileSpeed: 16,
    projectileRadius: 10,

    chaos: 1.0,
    multiElimChance: 0.08,
    nearMissChance: 0.10,
    ricochetChance: 0.06,

    screenShake: 12,
    popParticles: 22,
    popLife: 26,
    sparkLife: 18,
    slowMoFrames: 60,

    countdownSec: 3
  };

  let zorbImg, zorbLoaded = false;
  let rosterImgs = [];
  let players = [], projectiles = [], particles = [], stars = [];
  let paused = false, frameShake = 0;
  let zorb = { y:0, aimX:0, aimY:0, charge:0, recoil:0, fireCooldown:0 };

  let simState = "setup"; // setup | countdown | running | finished
  let countdownFrames = 0;

  let hudEl, hudStatusEl, panelEl, toastEl, controlsEl, inputEl;
  let panelRosterEl, panelZorbEl, startBtnEl;
  let uiHidden = false, hideTimer = null;

  function preload() {
    zorbImg = loadImage('zorb.png?v=4',
      () => { zorbLoaded = true; },
      () => { zorbLoaded = false; console.warn('Zorb failed to load. Ensure zorb.png is in repo root and lowercase.'); }
    );
  }

  function setup() {
    createOrResizeCanvas();
    hookUI();
    resetSim(true);
    updatePanelStatus();
    updateHud();
  }

  function windowResized() { createOrResizeCanvas(); }

  function createOrResizeCanvas() {
    const targetH = min(windowHeight, CFG.baseHeight);
    const targetW = targetH * (CFG.aspectW / CFG.aspectH);
    const w = min(windowWidth, targetW);
    const h = w * (CFG.aspectH / CFG.aspectW);
    createCanvas(floor(w), floor(h));
    pixelDensity(1);

    stars = [];
    for (let i = 0; i < 120; i++) {
      stars.push({ x: random(width), y: random(height), r: random(0.8, 2.2), tw: random(TAU), sp: random(0.006, 0.02) });
    }
  }

  function hookUI() {
    hudEl = document.getElementById('hud');
    hudStatusEl = document.getElementById('hudStatus');
    panelEl = document.getElementById('panel');
    toastEl = document.getElementById('toast');
    controlsEl = document.getElementById('controls');
    inputEl = document.getElementById('fileInput');
    panelRosterEl = document.getElementById('panelRoster');
    panelZorbEl   = document.getElementById('panelZorb');
    startBtnEl    = document.getElementById('startBtn');

    document.getElementById('btnShowPanel').addEventListener('click', () => { showPanel(true); showUI(true); });
    document.getElementById('btnPause').addEventListener('click', () => { togglePause(); bumpUI(); });
    document.getElementById('btnRestart').addEventListener('click', () => { resetSim(false); showUI(true); showPanel(true); });
    document.getElementById('btnChaosDown').addEventListener('click', () => { CFG.chaos = max(0.35, CFG.chaos - 0.15); bumpUI(); });
    document.getElementById('btnChaosUp').addEventListener('click', () => { CFG.chaos = min(3.0, CFG.chaos + 0.15); bumpUI(); });
    document.getElementById('btnHide').addEventListener('click', () => { setUIHidden(true); });

    document.getElementById('startNumbers').addEventListener('click', () => {
      rosterImgs = [];
      resetSim(false);
      enableStart(true);
      beginCountdown();
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      rosterImgs = [];
      enableStart(false);
      resetSim(true);
      showPanel(true);
      showUI(true);
      updatePanelStatus();
      bumpUI();
    });

    startBtnEl.addEventListener('click', () => beginCountdown());

    inputEl.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;

      shuffleInPlace(files);
      const picked = files.slice(0, CFG.playerCount);

      rosterImgs = [];
      for (const f of picked) {
        try { rosterImgs.push(await fileToP5Image(f)); }
        catch (err) { console.warn('Failed loading', f.name, err); }
      }

      resetSim(true);
      enableStart(true);
      updatePanelStatus();
      showPanel(true);
      showUI(true);
      bumpUI();
    });

    document.body.addEventListener('click', (e) => {
      if (!panelEl.classList.contains('hidden')) return;

      if (uiHidden) { showUI(true); bumpUI(); return; }
      togglePause();
      bumpUI();
    }, { passive: true });

    for (const el of document.querySelectorAll('button, label.btn')) {
      el.addEventListener('click', (ev) => ev.stopPropagation());
      el.addEventListener('touchstart', (ev) => ev.stopPropagation(), { passive: true });
    }

    showPanel(true);
    showUI(true);
  }

  function enableStart(on) { startBtnEl.disabled = !on; }

  function showPanel(show) { panelEl.classList.toggle('hidden', !show); }

  function togglePause() {
    if (simState === "setup") return;
    paused = !paused;
  }

  function beginCountdown() {
    showPanel(false);
    paused = false;
    simState = "countdown";
    countdownFrames = max(1, floor(CFG.countdownSec * 60));
    armAutoHide();
  }

  function showUI(withToast) {
    setUIHidden(false);
    if (withToast) toastPulse();
  }

  function setUIHidden(hidden) {
    uiHidden = hidden;
    hudEl.classList.toggle('hidden', hidden);
    controlsEl.classList.toggle('hidden', hidden);
  }

  function toastPulse() {
    toastEl.classList.add('show');
    setTimeout(() => toastEl.classList.remove('show'), 1100);
  }

  function armAutoHide() {
    if (hideTimer) clearTimeout(hideTimer);
    setUIHidden(false);
    hideTimer = setTimeout(() => setUIHidden(true), 2200);
  }

  function bumpUI() {
    if (hideTimer) clearTimeout(hideTimer);
    setUIHidden(false);
    hideTimer = setTimeout(() => setUIHidden(true), 1800);
  }

  function fileToP5Image(file) {
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      loadImage(url,
        (img) => { URL.revokeObjectURL(url); resolve(img); },
        (err) => { URL.revokeObjectURL(url); reject(err); }
      );
    });
  }

  function shuffleInPlace(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = floor(random(i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  function resetSim(keepSetupState) {
    players = []; projectiles = []; particles = []; frameShake = 0;
    paused = false;

    zorb.y = height * CFG.robotY;
    zorb.aimX = width * 0.5;
    zorb.aimY = height * 0.5;
    zorb.charge = 0;
    zorb.recoil = 0;
    zorb.fireCooldown = 0;

    simState = "setup";
    countdownFrames = 0;

    const topBound = height * 0.30;
    const areaH = height - topBound - 40;
    const cols = 5, rows = 10;
    const cellW = width / cols;
    const cellH = areaH / rows;

    for (let i = 0; i < CFG.playerCount; i++) {
      const r = random(CFG.bubbleMinR, CFG.bubbleMaxR);
      const cx = (i % cols) * cellW + cellW * 0.5;
      const cy = topBound + floor(i / cols) * cellH + cellH * 0.5;

      const x = constrain(cx + random(-cellW*0.25, cellW*0.25), r + 12, width - r - 12);
      const y = constrain(cy + random(-cellH*0.25, cellH*0.25), topBound + r + 8, height - r - 14);

      players.push(new Bubble(i + 1, x, y, r, rosterImgs[i] || null));
    }

    updatePanelStatus();
    updateHud();
  }

  function getRobotX() {
    const sway = sin(frameCount * CFG.robotSwaySpeedX) * (width * CFG.robotSwayFracX);
    const x = width * 0.5 + sway;
    const estHalf = (zorbLoaded && zorbImg) ? (zorbImg.width * CFG.robotScale * 0.52) : 120;
    return constrain(x, estHalf + 8, width - estHalf - 8);
  }

  function draw() {
    if (!paused) step();
    render();
    updateHud();
  }

  function step() {
    zorb.recoil *= 0.86;
    for (const s of stars) s.tw += s.sp;

    for (const b of players) b.update();
    for (let i = 0; i < players.length; i++) for (let j = i + 1; j < players.length; j++) players[i].separate(players[j]);

    for (let i = projectiles.length - 1; i >= 0; i--) { projectiles[i].update(); if (projectiles[i].dead) projectiles.splice(i, 1); }
    for (let i = particles.length - 1; i >= 0; i--) { particles[i].update(); if (particles[i].dead) particles.splice(i, 1); }

    if (simState === "countdown") {
      countdownFrames -= 1;
      if (countdownFrames <= 0) { simState = "running"; countdownFrames = 0; }
      return;
    }
    if (simState !== "running") return;

    zorb.fireCooldown -= deltaTime / 1000;
    if (zorb.fireCooldown <= 0 && players.length > 1) {
      let rate = CFG.fireRate;
      if (players.length <= 5) rate = CFG.fireRateFinal;
      if (players.length <= 2) rate = CFG.fireRateFinal2;

      if (players.length <= 5 && frameCount % CFG.slowMoFrames < 10) {
        // suspense hold
      } else {
        if (zorb.charge <= 0) {
          zorb.charge = CFG.chargeTime;
          const t = pickTarget();
          zorb.aimX = t.x + random(-CFG.aimJitter, CFG.aimJitter);
          zorb.aimY = t.y + random(-CFG.aimJitter, CFG.aimJitter);
          if (random() < CFG.nearMissChance * CFG.chaos) {
            zorb.aimX += random([-1, 1]) * random(40, 80);
            zorb.aimY += random(20, 60);
          }
        }
        zorb.charge -= 1;
        if (zorb.charge <= 0) {
          fireShot();
          zorb.fireCooldown = 1 / (rate * CFG.chaos);
        }
      }
    }

    if (players.length === 1) simState = "finished";
  }

  function pickTarget() {
    if (players.length > 12) return random(players);
    let best = players[0], bestScore = -1e9;
    for (const b of players) {
      const centerBias = -dist(b.x, b.y, width*0.5, height*0.62);
      const motion = b.v.mag() * 120;
      const score = centerBias + motion + random(-50, 50);
      if (score > bestScore) { bestScore = score; best = b; }
    }
    return best;
  }

  function cannonOrigins() {
    const robotX = getRobotX();
    const hoverY = sin(frameCount * CFG.robotHoverSpeedY) * CFG.robotHoverAmpY;

    const sx = CFG.robotScale;
    const imgW = (zorbLoaded && zorbImg) ? zorbImg.width * sx : 320 * sx;
    const imgH = (zorbLoaded && zorbImg) ? zorbImg.height * sx : 320 * sx;

    const left = robotX - imgW * 0.5;
    const top  = (zorb.y + hoverY) - imgH * 0.5;

    const y = top + imgH * CFG.cannonYFrac;
    return CFG.cannonXFrac.map(fr => ({ x: left + imgW * fr, y }));
  }

  function fireShot() {
    const origin = random(cannonOrigins());
    const dir = createVector(zorb.aimX - origin.x, zorb.aimY - origin.y).normalize();
    const speed = CFG.projectileSpeed * (0.85 + 0.3 * CFG.chaos);
    const vel = dir.mult(speed);

    const piercing = random() < CFG.multiElimChance * CFG.chaos;
    const ricochet = random() < CFG.ricochetChance * CFG.chaos;

    projectiles.push(new Projectile(origin.x, origin.y, vel.x, vel.y, piercing, ricochet));
    zorb.recoil = 1.0;
    frameShake = max(frameShake, CFG.screenShake * (players.length <= 5 ? 1.1 : 0.8));
  }

  function render() {
    let sx = 0, sy = 0;
    if (frameShake > 0 && !paused) {
      sx = random(-frameShake, frameShake);
      sy = random(-frameShake, frameShake);
      frameShake *= 0.86;
    }

    push();
    translate(sx, sy);

    background(CFG.bgColor);
    drawStars();
    if (CFG.vignette) drawVignette();

    for (const p of projectiles) p.draw();
    for (const b of players) b.draw();
    drawZorb();
    for (const pt of particles) pt.draw();

    if (simState === "countdown") drawCountdown();
    if (simState === "finished" && players.length === 1) drawWinner(players[0]);

    pop();
  }

  function drawStars() {
    noStroke();
    for (const s of stars) {
      const tw = (sin(s.tw) * 0.5 + 0.5);
      fill(180, 200, 255, 80 + tw * 175);
      circle(s.x, s.y, s.r);
    }
  }

  function drawVignette() {
    noFill();
    for (let i = 0; i < 14; i++) {
      stroke(0,0,0,14);
      rect(-i, -i, width + 2*i, height + 2*i, 22);
    }
  }

  function drawZorb() {
    const robotX = getRobotX();
    const hoverY = sin(frameCount * CFG.robotHoverSpeedY) * CFG.robotHoverAmpY;
    const scaleAmt = CFG.robotScale * (1 + zorb.recoil * 0.01);

    const halo = 34 + (CFG.chargeTime - zorb.charge) * 2;
    noStroke();
    fill(255, 0, 200, zorb.charge > 0 ? 60 : 26);
    circle(robotX, zorb.y + hoverY, halo * 2);

    imageMode(CENTER);
    if (zorbLoaded && zorbImg && zorbImg.width) {
      if (zorb.charge > 0) {
        push(); tint(255,255,255,210);
        image(zorbImg, robotX, zorb.y + hoverY, zorbImg.width * scaleAmt * 1.01, zorbImg.height * scaleAmt * 1.01);
        pop();
      }
      image(zorbImg, robotX, zorb.y + hoverY, zorbImg.width * scaleAmt, zorbImg.height * scaleAmt);
    } else {
      push();
      translate(robotX, zorb.y + hoverY);
      noStroke();
      fill(80, 240, 220, 210);
      ellipse(0,0,210,80);
      fill(255,0,200,55);
      ellipse(0,0,260,110);
      pop();
    }

    for (const o of cannonOrigins()) {
      const glow = zorb.charge > 0 ? map(zorb.charge, CFG.chargeTime, 0, 20, 130) : 18;
      noStroke();
      fill(255, 220, 0, glow);
      circle(o.x, o.y, 14);
    }
  }

  function drawCountdown() {
    const secLeft = ceil(countdownFrames / 60);
    noStroke();
    fill(0,0,0,110);
    rect(0,0,width,height);
    fill(255,255,255,240);
    textAlign(CENTER,CENTER);
    textSize(54);
    text(secLeft, width*0.5, height*0.50);
    textSize(16);
    fill(255,255,255,220);
    text("Zorbblez begins…", width*0.5, height*0.56);
  }

  function drawWinner(b) {
    noStroke();
    fill(0,0,0,120);
    rect(0,0,width,height);

    const cx = width*0.5, cy = height*0.52;
    const R  = min(width, height) * 0.23;
    const pulse = sin(frameCount*0.06)*0.5+0.5;

    noStroke();
    fill(120,220,255,30 + pulse*40);
    circle(cx, cy, R*2.45 + pulse*24);

    stroke(190,245,255,140);
    strokeWeight(5);
    fill(255,255,255,14);
    circle(cx, cy, R*2);

    noStroke();
    fill(255,255,255,58);
    ellipse(cx - R*0.28, cy - R*0.32, R*1.05, R*0.68);

    if (b.img) drawClippedImageCircle(b.img, cx, cy, R*1.62);
    else {
      fill(255,255,255,230);
      textAlign(CENTER, CENTER);
      textSize(R*0.7);
      text(b.id, cx, cy+6);
    }

    textAlign(CENTER, CENTER);
    noStroke();
    fill(255,255,255,240);
    textSize(34);
    text("WINNER!", cx, height*0.18);

    fill(255,255,255,220);
    textSize(16);
    text("Follow + comment to enter tomorrow’s round", cx, height*0.22);
  }

  function drawClippedImageCircle(img, x, y, d) {
    const ctx = drawingContext;
    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, d/2, 0, Math.PI*2);
    ctx.clip();

    const imgAR = img.width / img.height;
    let dw, dh;
    if (imgAR > 1) { dh = d; dw = d * imgAR; }
    else { dw = d; dh = d / imgAR; }
    imageMode(CENTER);
    image(img, x, y, dw, dh);

    ctx.restore();
  }

  class Bubble {
    constructor(id,x,y,r,img){
      this.id=id; this.x=x; this.y=y; this.r=r; this.img=img;
      this.v=createVector(random(-1,1),random(-1,1)).mult(random(0.5,1.35));
      this.wob=random(TAU); this.wobSp=random(0.02,0.05);
    }
    update(){
      const f=p5.Vector.random2D().mult(CFG.wanderForce*CFG.chaos);
      this.v.add(f);
      const maxV=CFG.maxSpeed*(0.85+0.35*CFG.chaos);
      if(this.v.mag()>maxV) this.v.setMag(maxV);

      this.x+=this.v.x; this.y+=this.v.y;
      const topBound=height*0.28;
      if(this.x<this.r){this.x=this.r; this.v.x*=-1;}
      if(this.x>width-this.r){this.x=width-this.r; this.v.x*=-1;}
      if(this.y<topBound+this.r){this.y=topBound+this.r; this.v.y*=-1;}
      if(this.y>height-this.r){this.y=height-this.r; this.v.y*=-1;}

      this.v.mult(CFG.bounceDamping);
      this.wob+=this.wobSp;
    }
    separate(o){
      const dx=o.x-this.x, dy=o.y-this.y;
      const d=Math.sqrt(dx*dx+dy*dy);
      const minD=this.r+o.r+6;
      if(d>0 && d<minD){
        const overlap=(minD-d)/minD;
        const push=overlap*CFG.separationStrength*(1+0.3*CFG.chaos);
        const nx=dx/d, ny=dy/d;

        this.x-=nx*push*40; this.y-=ny*push*40;
        o.x+=nx*push*40; o.y+=ny*push*40;

        this.v.x-=nx*push*1.2; this.v.y-=ny*push*1.2;
        o.v.x+=nx*push*1.2; o.v.y+=ny*push*1.2;
      }
    }
    draw(){
      push();
      translate(this.x,this.y);
      const wobble=1+sin(this.wob)*0.03;

      noStroke();
      fill(120,220,255,24);
      circle(0,0,this.r*2+CFG.bubbleGlow);

      stroke(190,245,255,110);
      strokeWeight(3);
      fill(255,255,255,14);
      ellipse(0,0,this.r*2*wobble,this.r*2*(2-wobble));

      if(this.img) drawClippedImageCircle(this.img, 0, 2, this.r*1.55);
      else{
        noStroke();
        fill(255,255,255,210);
        textAlign(CENTER,CENTER);
        textSize(this.r*0.6);
        text(this.id,0,6);
      }

      noStroke();
      fill(255,255,255,55);
      ellipse(-this.r*0.28,-this.r*0.32,this.r*0.85,this.r*0.55);
      pop();
    }
  }

  class Projectile{
    constructor(x,y,vx,vy,piercing=false,ricochet=false){
      this.x=x; this.y=y; this.v=createVector(vx,vy);
      this.r=CFG.projectileRadius; this.dead=false;
      this.piercing=piercing; this.ricochet=ricochet; this.hasRicocheted=false;
    }
    update(){
      this.x+=this.v.x; this.y+=this.v.y;
      if(this.y>height+120||this.x<-120||this.x>width+120){ this.dead=true; return; }

      for(let i=players.length-1;i>=0;i--){
        const b=players[i];
        if(dist(this.x,this.y,b.x,b.y)<b.r+this.r){
          popBubble(b);
          players.splice(i,1);

          if(!this.piercing) this.dead=true;
          else{
            this.r*=0.92; this.v.mult(0.92);
            if(this.r<6) this.dead=true;
          }

          if(this.ricochet && !this.hasRicocheted && !this.dead){
            this.hasRicocheted=true;
            const nv=p5.Vector.random2D().mult(CFG.projectileSpeed*0.85);
            nv.y=abs(nv.y)+6;
            this.v=nv;
          }
          break;
        }
      }
    }
    draw(){
      noStroke();
      fill(255,120,0,55);
      circle(this.x,this.y,this.r*4.4);
      fill(255,240,120,220);
      circle(this.x,this.y,this.r*1.8);
      stroke(255,255,255,70);
      strokeWeight(3);
      line(this.x,this.y,this.x-this.v.x*2.0,this.y-this.v.y*2.0);
    }
  }

  class Particle{
    constructor(x,y,vx,vy,life,kind='spark'){
      this.x=x; this.y=y; this.v=createVector(vx,vy);
      this.life=life; this.maxLife=life; this.kind=kind; this.dead=false;
      this.r=(kind==='pop')?random(3,7):random(2,4);
    }
    update(){ this.x+=this.v.x; this.y+=this.v.y; this.v.mult(0.93); this.life-=1; if(this.life<=0) this.dead=true; }
    draw(){
      const a=map(this.life,0,this.maxLife,0,255);
      noStroke();
      if(this.kind==='pop') fill(255,255,255,a);
      else fill(255,80,240,a);
      circle(this.x,this.y,this.r);
    }
  }

  function popBubble(b){
    frameShake=max(frameShake, CFG.screenShake*(players.length<=5?1.2:1.0));
    for(let i=0;i<CFG.popParticles;i++){
      const v=p5.Vector.random2D().mult(random(2.5,8.5));
      v.y+=1.2;
      particles.push(new Particle(b.x,b.y,v.x,v.y,CFG.sparkLife,'spark'));
    }
    for(let i=0;i<10;i++){
      const v=p5.Vector.random2D().mult(random(1.2,6.2));
      particles.push(new Particle(b.x,b.y,v.x,v.y,CFG.popLife,'pop'));
    }
  }

  function updatePanelStatus(){
    panelRosterEl.textContent = rosterImgs.length ? `Roster: ${rosterImgs.length} images` : 'Roster: numbers';
    panelZorbEl.textContent = zorbLoaded ? 'Zorb: OK' : 'Zorb: missing';
    panelZorbEl.classList.toggle('ok', zorbLoaded);
    panelZorbEl.classList.toggle('warn', !zorbLoaded);
    if (rosterImgs.length) enableStart(true);
    else enableStart(false);
  }

  function updateHud(){
    const roster = rosterImgs.length ? `${rosterImgs.length} img` : `numbers`;
    const z = zorbLoaded ? `ok` : `MISSING zorb.png`;
    const state = (simState === "setup") ? "SETUP" : (simState === "countdown") ? "COUNTDOWN" : (simState === "running") ? "RUNNING" : "FINISH";
    const cd = (simState === "countdown") ? ` • starts in ${ceil(countdownFrames/60)}s` : '';
    hudStatusEl.innerHTML =
      `State: <b>${state}</b> • Zorb: <b>${z}</b> • Roster: <b>${roster}</b> • Remaining: <b>${players.length}</b> • Chaos: <b>${CFG.chaos.toFixed(2)}</b>${cd}` +
      (paused ? ` • <b>PAUSED</b>` : ``);
    updatePanelStatus();
  }
  </script>
</body>
</html>
